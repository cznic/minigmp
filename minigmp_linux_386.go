// Code generated by ccgo. DO NOT EDIT.

// To obtain the original C sources please visit gmplib.org.

// Header extracted from minigmp.c:
//  /* mini-gmp, a minimalistic implementation of a GNU GMP subset.
//
//     Contributed to the GNU project by Niels Möller
//
//  Copyright 1991-1997, 1999-2016 Free Software Foundation, Inc.
//
//  This file is part of the GNU MP Library.
//
//  The GNU MP Library is free software; you can redistribute it and/or modify
//  it under the terms of either:
//
//    * the GNU Lesser General Public License as published by the Free
//      Software Foundation; either version 3 of the License, or (at your
//      option) any later version.
//
//  or
//
//    * the GNU General Public License as published by the Free Software
//      Foundation; either version 2 of the License, or (at your option) any
//      later version.
//
//  or both in parallel, as here.
//
//  The GNU MP Library is distributed in the hope that it will be useful, but
//  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
//  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
//  for more details.
//
//  You should have received copies of the GNU General Public License and the
//  GNU Lesser General Public License along with the GNU MP Library.  If not,
//  see https://www.gnu.org/licenses/.  */
//
//  /* NOTE: All functions in this file which are not declared in
//     mini-gmp.h are internal, and are not intended to be compatible
//     neither with GMP nor with future versions of mini-gmp. */
//
//  /* Much of the material copied from GMP files, including: gmp-impl.h,
//     longlong.h, mpn/generic/add_n.c, mpn/generic/addmul_1.c,
//     mpn/generic/lshift.c, mpn/generic/mul_1.c,
//     mpn/generic/mul_basecase.c, mpn/generic/rshift.c,
//     mpn/generic/sbpi1_div_qr.c, mpn/generic/sub_n.c,
//     mpn/generic/submul_1.c. */
package minigmp

import (
	"fmt"
	"math"
	"os"
	"path"
	"runtime"
	"unsafe"

	"github.com/cznic/ccgo/crt"
)

func ftrace(s string, args ...interface{}) {
	_, fn, fl, _ := runtime.Caller(1)
	fmt.Fprintf(os.Stderr, "# %s:%d: %v\n", path.Base(fn), fl, fmt.Sprintf(s, args...))
	os.Stderr.Sync()
}

const (
	X_STDC_PREDEF_H            = 1
	X__ATOMIC_ACQUIRE          = 2
	X__ATOMIC_ACQ_REL          = 4
	X__ATOMIC_CONSUME          = 1
	X__ATOMIC_HLE_ACQUIRE      = 65536
	X__ATOMIC_HLE_RELEASE      = 131072
	X__ATOMIC_RELAXED          = 0
	X__ATOMIC_RELEASE          = 3
	X__ATOMIC_SEQ_CST          = 5
	X__BIGGEST_ALIGNMENT__     = 16
	X__BYTE_ORDER__            = 1234
	X__CHAR_BIT__              = 8
	X__DBL_DECIMAL_DIG__       = 17
	X__DBL_DIG__               = 15
	X__DBL_HAS_DENORM__        = 1
	X__DBL_HAS_INFINITY__      = 1
	X__DBL_HAS_QUIET_NAN__     = 1
	X__DBL_MANT_DIG__          = 53
	X__DBL_MAX_10_EXP__        = 308
	X__DBL_MAX_EXP__           = 1024
	X__DBL_MIN_10_EXP__        = -307
	X__DBL_MIN_EXP__           = -1021
	X__DEC128_MANT_DIG__       = 34
	X__DEC128_MAX_EXP__        = 6145
	X__DEC128_MIN_EXP__        = -6142
	X__DEC32_MANT_DIG__        = 7
	X__DEC32_MAX_EXP__         = 97
	X__DEC32_MIN_EXP__         = -94
	X__DEC64_MANT_DIG__        = 16
	X__DEC64_MAX_EXP__         = 385
	X__DEC64_MIN_EXP__         = -382
	X__DECIMAL_BID_FORMAT__    = 1
	X__DECIMAL_DIG__           = 21
	X__DEC_EVAL_METHOD__       = 2
	X__FINITE_MATH_ONLY__      = 0
	X__FLOAT_WORD_ORDER__      = 1234
	X__FLT_DECIMAL_DIG__       = 9
	X__FLT_DENORM_MIN__        = 1e-45
	X__FLT_DIG__               = 6
	X__FLT_EPSILON__           = 1.1920929e-07
	X__FLT_EVAL_METHOD__       = 2
	X__FLT_HAS_DENORM__        = 1
	X__FLT_HAS_INFINITY__      = 1
	X__FLT_HAS_QUIET_NAN__     = 1
	X__FLT_MANT_DIG__          = 24
	X__FLT_MAX_10_EXP__        = 38
	X__FLT_MAX_EXP__           = 128
	X__FLT_MAX__               = 3.4028235e+38
	X__FLT_MIN_10_EXP__        = -37
	X__FLT_MIN_EXP__           = -125
	X__FLT_MIN__               = 1.1754944e-38
	X__FLT_RADIX__             = 2
	X__FUNCTION__              = 0
	X__GXX_ABI_VERSION         = 1010
	X__INT16_MAX__             = 32767
	X__INT32_MAX__             = 2147483647
	X__INT32_TYPE__            = 0
	X__INT64_MAX__             = 9223372036854775807
	X__INT8_MAX__              = 127
	X__INTMAX_MAX__            = 9223372036854775807
	X__INTPTR_MAX__            = 2147483647
	X__INTPTR_TYPE__           = 0
	X__INT_FAST16_MAX__        = 2147483647
	X__INT_FAST16_TYPE__       = 0
	X__INT_FAST32_MAX__        = 2147483647
	X__INT_FAST32_TYPE__       = 0
	X__INT_FAST64_MAX__        = 9223372036854775807
	X__INT_FAST8_MAX__         = 127
	X__INT_LEAST16_MAX__       = 32767
	X__INT_LEAST32_MAX__       = 2147483647
	X__INT_LEAST32_TYPE__      = 0
	X__INT_LEAST64_MAX__       = 9223372036854775807
	X__INT_LEAST8_MAX__        = 127
	X__INT_MAX__               = 2147483647
	X__LDBL_DENORM_MIN__       = 0
	X__LDBL_DIG__              = 18
	X__LDBL_EPSILON__          = 1.0842021724855044e-19
	X__LDBL_HAS_DENORM__       = 1
	X__LDBL_HAS_INFINITY__     = 1
	X__LDBL_HAS_QUIET_NAN__    = 1
	X__LDBL_MANT_DIG__         = 64
	X__LDBL_MAX_10_EXP__       = 4932
	X__LDBL_MAX_EXP__          = 16384
	X__LDBL_MAX__              = 0
	X__LDBL_MIN_10_EXP__       = -4931
	X__LDBL_MIN_EXP__          = -16381
	X__LDBL_MIN__              = 0
	X__LONG_LONG_MAX__         = 9223372036854775807
	X__LONG_MAX__              = 2147483647
	X__NO_INLINE__             = 1
	X__ORDER_BIG_ENDIAN__      = 4321
	X__ORDER_LITTLE_ENDIAN__   = 1234
	X__ORDER_PDP_ENDIAN__      = 3412
	X__PRAGMA_REDEFINE_EXTNAME = 1
	X__PTRDIFF_MAX__           = 2147483647
	X__PTRDIFF_TYPE__          = 0
	X__SCHAR_MAX__             = 127
	X__SEG_FS                  = 1
	X__SEG_GS                  = 1
	X__SHRT_MAX__              = 32767
	X__SIG_ATOMIC_MAX__        = 2147483647
	X__SIG_ATOMIC_MIN__        = -2147483648
	X__SIG_ATOMIC_TYPE__       = 0
	X__SIZEOF_DOUBLE__         = 8
	X__SIZEOF_FLOAT128__       = 16
	X__SIZEOF_FLOAT80__        = 12
	X__SIZEOF_FLOAT__          = 4
	X__SIZEOF_INT__            = 4
	X__SIZEOF_LONG_DOUBLE__    = 12
	X__SIZEOF_LONG_LONG__      = 8
	X__SIZEOF_LONG__           = 4
	X__SIZEOF_POINTER__        = 4
	X__SIZEOF_PTRDIFF_T__      = 4
	X__SIZEOF_SHORT__          = 2
	X__SIZEOF_SIZE_T__         = 4
	X__SIZEOF_WCHAR_T__        = 4
	X__SIZEOF_WINT_T__         = 4
	X__SIZE_MAX__              = 4294967295
	X__SSP_STRONG__            = 3
	X__STDC_HOSTED__           = 1
	X__STDC_IEC_559_COMPLEX__  = 1
	X__STDC_IEC_559__          = 1
	X__STDC_ISO_10646__        = 201505
	X__STDC_NO_THREADS__       = 1
	X__STDC_VERSION__          = 199901
	X__STDC__                  = 1
	X__STRICT_ANSI__           = 1
	X__UINT16_MAX__            = 65535
	X__UINT32_MAX__            = 4294967295
	X__UINT64_MAX__            = 18446744073709551615
	X__UINT8_MAX__             = 255
	X__UINTMAX_MAX__           = 18446744073709551615
	X__UINTPTR_MAX__           = 4294967295
	X__UINT_FAST16_MAX__       = 4294967295
	X__UINT_FAST32_MAX__       = 4294967295
	X__UINT_FAST64_MAX__       = 18446744073709551615
	X__UINT_FAST8_MAX__        = 255
	X__UINT_LEAST16_MAX__      = 65535
	X__UINT_LEAST32_MAX__      = 4294967295
	X__UINT_LEAST64_MAX__      = 18446744073709551615
	X__UINT_LEAST8_MAX__       = 255
	X__VERSION__               = "6.2.0 20161005"
	X__WCHAR_MAX__             = 2147483647
	X__WCHAR_MIN__             = -2147483648
	X__WINT_MAX__              = 4294967295
	X__WINT_MIN__              = 0
	X__code_model_32__         = 1
	X__complex__               = 0
	X__const                   = 0
	X__i386                    = 1
	X__i386__                  = 1
	X__i686                    = 1
	X__i686__                  = 1
	X__inline                  = 0
	X__linux                   = 1
	X__linux__                 = 1
	X__pentiumpro              = 1
	X__pentiumpro__            = 1
	X__restrict                = 0
	X__unix                    = 1
	X__unix__                  = 1
	X__volatile                = 0
)

var Xstderr unsafe.Pointer

func Xmp_set_memory_functions(tls *crt.TLS, _alloc_func func(*crt.TLS, uint32) unsafe.Pointer, _realloc_func func(*crt.TLS, unsafe.Pointer, uint32, uint32) unsafe.Pointer, _free_func func(*crt.TLS, unsafe.Pointer, uint32)) {
	if _alloc_func == nil {
		_alloc_func = _gmp_default_alloc
	}
	if _realloc_func == nil {
		_realloc_func = _gmp_default_realloc
	}
	if _free_func == nil {
		_free_func = _gmp_default_free
	}
	_gmp_allocate_func = _alloc_func
	bug20530(_gmp_allocate_func)
	_gmp_reallocate_func = _realloc_func
	bug20530(_gmp_reallocate_func)
	_gmp_free_func = _free_func
	bug20530(_gmp_free_func)
}

func _gmp_default_alloc(tls *crt.TLS, _size uint32) (r0 unsafe.Pointer) {
	var _p unsafe.Pointer

	_p = crt.Xmalloc(tls, _size)
	if _p == nil {
		_gmp_die(tls, str(0))
	}
	return _p
}

// C comment
//  /* Memory allocation and other helper functions. */
func _gmp_die(tls *crt.TLS, _msg *int8) { panic(crt.GoString(_msg)) }

func _gmp_default_realloc(tls *crt.TLS, _old unsafe.Pointer, _old_size uint32, _new_size uint32) (r0 unsafe.Pointer) {
	var _p unsafe.Pointer
	_p = crt.Xrealloc(tls, _old, _new_size)
	if _p == nil {
		_gmp_die(tls, str(49))
	}
	return _p
}

func _gmp_default_free(tls *crt.TLS, _p unsafe.Pointer, _size uint32) {
	crt.Xfree(tls, _p)
}

var _gmp_allocate_func func(*crt.TLS, uint32) unsafe.Pointer

func init() {
	_gmp_allocate_func = _gmp_default_alloc
}

var _gmp_reallocate_func func(*crt.TLS, unsafe.Pointer, uint32, uint32) unsafe.Pointer

func init() {
	_gmp_reallocate_func = _gmp_default_realloc
}

var _gmp_free_func func(*crt.TLS, unsafe.Pointer, uint32)

func init() {
	_gmp_free_func = _gmp_default_free
}

func Xmp_get_memory_functions(tls *crt.TLS, _alloc_func *func(*crt.TLS, uint32) unsafe.Pointer, _realloc_func *func(*crt.TLS, unsafe.Pointer, uint32, uint32) unsafe.Pointer, _free_func *func(*crt.TLS, unsafe.Pointer, uint32)) {
	if _alloc_func != nil {
		*_alloc_func = _gmp_allocate_func
	}
	if _realloc_func != nil {
		*_realloc_func = _gmp_reallocate_func
	}
	if _free_func != nil {
		*_free_func = _gmp_free_func
	}
}

var Xmp_bits_per_limb int32

func init() {
	Xmp_bits_per_limb = int32(32)
}

func Xmpn_copyi(tls *crt.TLS, _d *uint32, _s *uint32, _n int32) {
	var _i int32
	_i = int32(0)
_0:
	if _i >= _n {
		goto _3
	}
	*elem0(_d, uintptr(_i)) = *elem0(_s, uintptr(_i))
	_i += 1
	goto _0
_3:
}

func Xmpn_copyd(tls *crt.TLS, _d *uint32, _s *uint32, _n int32) {
_0:
	if preInc1(&_n, -1) >= int32(0) {
		*elem0(_d, uintptr(_n)) = *elem0(_s, uintptr(_n))
		goto _0
	}
}

func Xmpn_zero(tls *crt.TLS, _rp *uint32, _n int32) {
_0:
	if preInc1(&_n, -1) >= int32(0) {
		*elem0(_rp, uintptr(_n)) = 0
		goto _0
	}
}

func Xmpn_cmp(tls *crt.TLS, _ap *uint32, _bp *uint32, _n int32) (r0 int32) {
_0:
	if preInc1(&_n, -1) < int32(0) {
		goto _1
	}
	if (*elem0(_ap, uintptr(_n))) != (*elem0(_bp, uintptr(_n))) {
		return func() int32 {
			if (*elem0(_ap, uintptr(_n))) > (*elem0(_bp, uintptr(_n))) {
				return int32(1)
			}
			return int32(-1)
		}()
	}
	goto _0
_1:
	return int32(0)
}

func Xmpn_zero_p(tls *crt.TLS, _rp *uint32, _n int32) (r0 int32) {
	return bool2int(_mpn_normalized_size(tls, _rp, _n) == int32(0))
}

func _mpn_normalized_size(tls *crt.TLS, _xp *uint32, _n int32) (r0 int32) {
_0:
	if (_n > int32(0)) && ((*elem0(_xp, uintptr(_n-int32(1)))) == 0) {
		_n -= 1
		goto _0
	}
	return _n
}

func Xmpn_add_1(tls *crt.TLS, _rp *uint32, _ap *uint32, _n int32, _b uint32) (r0 uint32) {
	var _i int32
	var _1_r uint32

	_i = int32(0)
_0:
	_1_r = (*elem0(_ap, uintptr(_i))) + _b
	_b = uint32(bool2int(_1_r < _b))
	*elem0(_rp, uintptr(_i)) = _1_r
	if preInc1(&_i, 1) < _n {
		goto _0
	}
	return _b
}

func Xmpn_add_n(tls *crt.TLS, _rp *uint32, _ap *uint32, _bp *uint32, _n int32) (r0 uint32) {
	var _i int32
	var _cy, _1_a, _1_b, _1_r uint32
	*func() *uint32 { _i = int32(0); return &_cy }() = 0
_0:
	if _i >= _n {
		goto _3
	}
	_1_a = *elem0(_ap, uintptr(_i))
	_1_b = *elem0(_bp, uintptr(_i))
	_1_r = _1_a + _cy
	_cy = uint32(bool2int(_1_r < _cy))
	_1_r += _1_b
	_cy += uint32(bool2int(_1_r < _1_b))
	*elem0(_rp, uintptr(_i)) = _1_r
	_i += 1
	goto _0
_3:
	return _cy
}

func Xmpn_add(tls *crt.TLS, _rp *uint32, _ap *uint32, _an int32, _bp *uint32, _bn int32) (r0 uint32) {
	var _cy uint32

	_cy = Xmpn_add_n(tls, _rp, _ap, _bp, _bn)
	if _an > _bn {
		_cy = Xmpn_add_1(tls, elem0(_rp, uintptr(_bn)), elem0(_ap, uintptr(_bn)), _an-_bn, _cy)
	}
	return _cy
}

func Xmpn_sub_1(tls *crt.TLS, _rp *uint32, _ap *uint32, _n int32, _b uint32) (r0 uint32) {
	var _i int32
	var _1_a, _1_cy uint32

	_i = int32(0)
_0:
	_1_a = *elem0(_ap, uintptr(_i))
	_1_cy = uint32(bool2int(_1_a < _b))
	*elem0(_rp, uintptr(_i)) = _1_a - _b
	_b = _1_cy
	if preInc1(&_i, 1) < _n {
		goto _0
	}
	return _b
}

func Xmpn_sub_n(tls *crt.TLS, _rp *uint32, _ap *uint32, _bp *uint32, _n int32) (r0 uint32) {
	var _i int32
	var _cy, _1_a, _1_b uint32
	*func() *uint32 { _i = int32(0); return &_cy }() = 0
_0:
	if _i >= _n {
		goto _3
	}
	_1_a = *elem0(_ap, uintptr(_i))
	_1_b = *elem0(_bp, uintptr(_i))
	_1_b += _cy
	_cy = uint32(bool2int(_1_b < _cy))
	_cy += uint32(bool2int(_1_a < _1_b))
	*elem0(_rp, uintptr(_i)) = _1_a - _1_b
	_i += 1
	goto _0
_3:
	return _cy
}

func Xmpn_sub(tls *crt.TLS, _rp *uint32, _ap *uint32, _an int32, _bp *uint32, _bn int32) (r0 uint32) {
	var _cy uint32

	_cy = Xmpn_sub_n(tls, _rp, _ap, _bp, _bn)
	if _an > _bn {
		_cy = Xmpn_sub_1(tls, elem0(_rp, uintptr(_bn)), elem0(_ap, uintptr(_bn)), _an-_bn, _cy)
	}
	return _cy
}

func Xmpn_mul_1(tls *crt.TLS, _rp *uint32, _up *uint32, _n int32, _vl uint32) (r0 uint32) {
	var _ul, _cl, _hpl, _lpl, _2___x0, _2___x1, _2___x2, _2___x3, _2___ul, _2___vl, _2___uh, _2___vh, _2___u, _2___v uint32

	_cl = 0
_0:
	_ul = *postInc0(&_up, 4)
	_2___u = _ul
	_2___v = _vl
	_2___ul = _2___u & uint32(65535)
	_2___uh = _2___u >> 16
	_2___vl = _2___v & uint32(65535)
	_2___vh = _2___v >> 16
	_2___x0 = _2___ul * _2___vl
	_2___x1 = _2___ul * _2___vh
	_2___x2 = _2___uh * _2___vl
	_2___x3 = _2___uh * _2___vh
	_2___x1 += _2___x0 >> 16
	_2___x1 += _2___x2
	if _2___x1 < _2___x2 {
		_2___x3 += uint32(65536)
	}
	_hpl = _2___x3 + (_2___x1 >> 16)
	_lpl = (_2___x1 << 16) + (_2___x0 & uint32(65535))
	_lpl += _cl
	_cl = uint32(bool2int(_lpl < _cl)) + _hpl
	*postInc0(&_rp, 4) = _lpl
	if preInc1(&_n, -1) != int32(0) {
		goto _0
	}
	return _cl
}

func Xmpn_addmul_1(tls *crt.TLS, _rp *uint32, _up *uint32, _n int32, _vl uint32) (r0 uint32) {
	var _ul, _cl, _hpl, _lpl, _rl, _2___x0, _2___x1, _2___x2, _2___x3, _2___ul, _2___vl, _2___uh, _2___vh, _2___u, _2___v uint32

	_cl = 0
_0:
	_ul = *postInc0(&_up, 4)
	_2___u = _ul
	_2___v = _vl
	_2___ul = _2___u & uint32(65535)
	_2___uh = _2___u >> 16
	_2___vl = _2___v & uint32(65535)
	_2___vh = _2___v >> 16
	_2___x0 = _2___ul * _2___vl
	_2___x1 = _2___ul * _2___vh
	_2___x2 = _2___uh * _2___vl
	_2___x3 = _2___uh * _2___vh
	_2___x1 += _2___x0 >> 16
	_2___x1 += _2___x2
	if _2___x1 < _2___x2 {
		_2___x3 += uint32(65536)
	}
	_hpl = _2___x3 + (_2___x1 >> 16)
	_lpl = (_2___x1 << 16) + (_2___x0 & uint32(65535))
	_lpl += _cl
	_cl = uint32(bool2int(_lpl < _cl)) + _hpl
	_rl = *_rp
	_lpl = _rl + _lpl
	_cl += uint32(bool2int(_lpl < _rl))
	*postInc0(&_rp, 4) = _lpl
	if preInc1(&_n, -1) != int32(0) {
		goto _0
	}
	return _cl
}

func Xmpn_submul_1(tls *crt.TLS, _rp *uint32, _up *uint32, _n int32, _vl uint32) (r0 uint32) {
	var _ul, _cl, _hpl, _lpl, _rl, _2___x0, _2___x1, _2___x2, _2___x3, _2___ul, _2___vl, _2___uh, _2___vh, _2___u, _2___v uint32

	_cl = 0
_0:
	_ul = *postInc0(&_up, 4)
	_2___u = _ul
	_2___v = _vl
	_2___ul = _2___u & uint32(65535)
	_2___uh = _2___u >> 16
	_2___vl = _2___v & uint32(65535)
	_2___vh = _2___v >> 16
	_2___x0 = _2___ul * _2___vl
	_2___x1 = _2___ul * _2___vh
	_2___x2 = _2___uh * _2___vl
	_2___x3 = _2___uh * _2___vh
	_2___x1 += _2___x0 >> 16
	_2___x1 += _2___x2
	if _2___x1 < _2___x2 {
		_2___x3 += uint32(65536)
	}
	_hpl = _2___x3 + (_2___x1 >> 16)
	_lpl = (_2___x1 << 16) + (_2___x0 & uint32(65535))
	_lpl += _cl
	_cl = uint32(bool2int(_lpl < _cl)) + _hpl
	_rl = *_rp
	_lpl = _rl - _lpl
	_cl += uint32(bool2int(_lpl > _rl))
	*postInc0(&_rp, 4) = _lpl
	if preInc1(&_n, -1) != int32(0) {
		goto _0
	}
	return _cl
}

func Xmpn_mul(tls *crt.TLS, _rp *uint32, _up *uint32, _un int32, _vp *uint32, _vn int32) (r0 uint32) {
	*elem0(_rp, uintptr(_un)) = Xmpn_mul_1(tls, _rp, _up, _un, *_vp)
_0:
	if preInc1(&_vn, -1) >= int32(1) {
		*(*uintptr)(unsafe.Pointer(func() **uint32 {
			*(*uintptr)(unsafe.Pointer(&_rp)) += 4 * uintptr(int32(1))
			return &_vp
		}())) += 4 * uintptr(int32(1))
		*elem0(_rp, uintptr(_un)) = Xmpn_addmul_1(tls, _rp, _up, _un, *_vp)
		goto _0
	}
	return *elem0(_rp, uintptr(_un))
}

func Xmpn_mul_n(tls *crt.TLS, _rp *uint32, _ap *uint32, _bp *uint32, _n int32) {
	Xmpn_mul(tls, _rp, _ap, _n, _bp, _n)
}

func Xmpn_sqr(tls *crt.TLS, _rp *uint32, _ap *uint32, _n int32) {
	Xmpn_mul(tls, _rp, _ap, _n, _ap, _n)
}

func Xmpn_perfect_square_p(tls *crt.TLS, _p *uint32, _n int32) (r0 int32) {
	var _t [1]Xmpz_srcptr
	return Xmpz_root(tls, nil, (*[1]Xmpz_srcptr)(unsafe.Pointer(Xmpz_roinit_n(tls, &_t, _p, _n))), uint32(2))
}

func Xmpz_root(tls *crt.TLS, _x *[1]Xmpz_srcptr, _y *[1]Xmpz_srcptr, _z uint32) (r0 int32) {
	var _res int32
	var _r [1]Xmpz_srcptr
	Xmpz_init(tls, &_r)
	Xmpz_rootrem(tls, _x, &_r, _y, _z)
	_res = bool2int((_r[0].X_mp_size) == int32(0))
	Xmpz_clear(tls, &_r)
	return _res
}

// C comment
//  /* MPZ interface */
func Xmpz_init(tls *crt.TLS, _r *[1]Xmpz_srcptr) {
	_r[0].X_mp_alloc = int32(0)
	_r[0].X_mp_size = int32(0)
	_r[0].X_mp_d = &_mpz_initØ00dummy_limbØ001
}

var _mpz_initØ00dummy_limbØ001 uint32

func init() {
	_mpz_initØ00dummy_limbØ001 = uint32(49568)
}

// C comment
//  /* x=trunc(y^(1/z)), r=y-x^z */
func Xmpz_rootrem(tls *crt.TLS, _x *[1]Xmpz_srcptr, _r *[1]Xmpz_srcptr, _y *[1]Xmpz_srcptr, _z uint32) {
	var _sgn int32
	var _t, _u, _3_v [1]Xmpz_srcptr
	_sgn = bool2int((_y[0].X_mp_size) < int32(0))
	if ((^_z) & uint32(_sgn)) != 0 {
		_gmp_die(tls, str(96))
	}
	if _z == 0 {
		_gmp_die(tls, str(144))
	}
	if Xmpz_cmpabs_ui(tls, _y, uint32(1)) > int32(0) {
		goto _2
	}
	if _x != nil {
		Xmpz_set(tls, _x, _y)
	}
	if _r != nil {
		_r[0].X_mp_size = int32(0)
	}
	return
_2:
	Xmpz_init(tls, &_u)
	Xmpz_init(tls, &_t)
	Xmpz_setbit(tls, &_t, (Xmpz_sizeinbase(tls, _y, int32(2))/_z)+uint32(1))
	if _z != uint32(2) {
		goto _5
	}
_6:
	Xmpz_swap(tls, &_u, &_t)
	Xmpz_tdiv_q(tls, &_t, _y, &_u)
	Xmpz_add(tls, &_t, &_t, &_u)
	Xmpz_tdiv_q_2exp(tls, &_t, &_t, uint32(1))
	if Xmpz_cmpabs(tls, &_t, &_u) < int32(0) {
		goto _6
	}
	goto _7
_5:
	Xmpz_init(tls, &_3_v)
	if _sgn != 0 {
		Xmpz_neg(tls, &_t, &_t)
	}
_8:
	Xmpz_swap(tls, &_u, &_t)
	Xmpz_pow_ui(tls, &_t, &_u, _z-uint32(1))
	Xmpz_tdiv_q(tls, &_t, _y, &_t)
	Xmpz_mul_ui(tls, &_3_v, &_u, _z-uint32(1))
	Xmpz_add(tls, &_t, &_t, &_3_v)
	Xmpz_tdiv_q_ui(tls, &_t, &_t, _z)
	if Xmpz_cmpabs(tls, &_t, &_u) < int32(0) {
		goto _8
	}
	Xmpz_clear(tls, &_3_v)
_7:
	if _r != nil {
		Xmpz_pow_ui(tls, &_t, &_u, _z)
		Xmpz_sub(tls, _r, _y, &_t)
	}
	if _x != nil {
		Xmpz_swap(tls, _x, &_u)
	}
	Xmpz_clear(tls, &_u)
	Xmpz_clear(tls, &_t)
}

func Xmpz_cmpabs_ui(tls *crt.TLS, _u *[1]Xmpz_srcptr, _v uint32) (r0 int32) {
	if func() int32 {
		if (_u[0].X_mp_size) >= int32(0) {
			return (_u[0].X_mp_size)
		}
		return (-(_u[0].X_mp_size))
	}() > int32(1) {
		return int32(1)
	}
	return bool2int(Xmpz_get_ui(tls, _u) > _v) - bool2int(Xmpz_get_ui(tls, _u) < _v)
}

func Xmpz_get_ui(tls *crt.TLS, _u *[1]Xmpz_srcptr) (r0 uint32) {
	return func() uint32 {
		if (_u[0].X_mp_size) == int32(0) {
			return 0
		}
		return (*(_u[0].X_mp_d))
	}()
}

func Xmpz_set(tls *crt.TLS, _r *[1]Xmpz_srcptr, _x *[1]Xmpz_srcptr) {
	var _1_n int32
	var _1_rp *uint32
	if &_r[0] != &_x[0] {
		_1_n = func() int32 {
			if (_x[0].X_mp_size) >= int32(0) {
				return (_x[0].X_mp_size)
			}
			return (-(_x[0].X_mp_size))
		}()
		_1_rp = func() *uint32 {
			if _1_n > (_r[0].X_mp_alloc) {
				return _mpz_realloc(tls, _r, _1_n)
			}
			return (_r[0].X_mp_d)
		}()
		Xmpn_copyi(tls, _1_rp, _x[0].X_mp_d, _1_n)
		_r[0].X_mp_size = _x[0].X_mp_size
	}
}

func _mpz_realloc(tls *crt.TLS, _r *[1]Xmpz_srcptr, _size int32) (r0 *uint32) {
	_size = func() int32 {
		if _size > int32(1) {
			return _size
		}
		return int32(1)
	}()
	if (_r[0].X_mp_alloc) != 0 {
		_r[0].X_mp_d = _gmp_xrealloc_limbs(tls, _r[0].X_mp_d, _size)
		goto _3
	}
	_r[0].X_mp_d = _gmp_xalloc_limbs(tls, _size)
_3:
	_r[0].X_mp_alloc = _size
	if func() int32 {
		if (_r[0].X_mp_size) >= int32(0) {
			return (_r[0].X_mp_size)
		}
		return (-(_r[0].X_mp_size))
	}() > _size {
		_r[0].X_mp_size = int32(0)
	}
	return _r[0].X_mp_d
}

func _gmp_xrealloc_limbs(tls *crt.TLS, _old *uint32, _size int32) (r0 *uint32) {
	return (*uint32)(_gmp_reallocate_func(tls, unsafe.Pointer(_old), 0, uint32(_size)*uint32(4)))
}

func _gmp_xalloc_limbs(tls *crt.TLS, _size int32) (r0 *uint32) {
	return (*uint32)(_gmp_allocate_func(tls, uint32(_size)*uint32(4)))
}

func Xmpz_setbit(tls *crt.TLS, _d *[1]Xmpz_srcptr, _bit_index uint32) {
	if Xmpz_tstbit(tls, _d, _bit_index) != 0 {
		goto _0
	}
	if (_d[0].X_mp_size) >= int32(0) {
		_mpz_abs_add_bit(tls, _d, _bit_index)
		goto _2
	}
	_mpz_abs_sub_bit(tls, _d, _bit_index)
_2:
_0:
}

func Xmpz_tstbit(tls *crt.TLS, _d *[1]Xmpz_srcptr, _bit_index uint32) (r0 int32) {
	var _limb_index, _ds, _dn, _bit int32
	var _shift, _w uint32
	_ds = _d[0].X_mp_size
	_dn = func() int32 {
		if _ds >= int32(0) {
			return _ds
		}
		return (-_ds)
	}()
	_limb_index = int32(_bit_index / uint32(32))
	if _limb_index >= _dn {
		return bool2int(_ds < int32(0))
	}
	_shift = _bit_index % uint32(32)
	_w = *elem0(_d[0].X_mp_d, uintptr(_limb_index))
	_bit = int32((_w >> uint(int32(_shift))) & uint32(1))
	if _ds >= int32(0) {
		goto _3
	}
	if (_shift > 0) && ((_w << uint(int32(uint32(32)-_shift))) > 0) {
		return _bit ^ int32(1)
	}
_5:
	if preInc1(&_limb_index, -1) < int32(0) {
		goto _7
	}
	if (*elem0(_d[0].X_mp_d, uintptr(_limb_index))) > 0 {
		return _bit ^ int32(1)
	}
	goto _5
_7:
_3:
	return _bit
}

func _mpz_abs_add_bit(tls *crt.TLS, _d *[1]Xmpz_srcptr, _bit_index uint32) {
	var _dn, _limb_index, _1_i int32
	var _bit, _2_cy uint32
	var _dp *uint32
	_dn = func() int32 {
		if (_d[0].X_mp_size) >= int32(0) {
			return (_d[0].X_mp_size)
		}
		return (-(_d[0].X_mp_size))
	}()
	_limb_index = int32(_bit_index / uint32(32))
	_bit = uint32(1) << uint(int32(_bit_index%uint32(32)))
	if _limb_index < _dn {
		goto _2
	}
	_dp = func() *uint32 {
		if (_limb_index + int32(1)) > (_d[0].X_mp_alloc) {
			return _mpz_realloc(tls, _d, _limb_index+int32(1))
		}
		return (_d[0].X_mp_d)
	}()
	*elem0(_dp, uintptr(_limb_index)) = _bit
	_1_i = _dn
_5:
	if _1_i >= _limb_index {
		goto _8
	}
	*elem0(_dp, uintptr(_1_i)) = 0
	_1_i += 1
	goto _5
_8:
	_dn = _limb_index + int32(1)
	goto _9
_2:
	_dp = _d[0].X_mp_d
	_2_cy = Xmpn_add_1(tls, elem0(_dp, uintptr(_limb_index)), elem0(_dp, uintptr(_limb_index)), _dn-_limb_index, _bit)
	if _2_cy > 0 {
		_dp = func() *uint32 {
			if (_dn + int32(1)) > (_d[0].X_mp_alloc) {
				return _mpz_realloc(tls, _d, _dn+int32(1))
			}
			return (_d[0].X_mp_d)
		}()
		*elem0(_dp, uintptr(postInc1(&_dn, 1))) = _2_cy
	}
_9:
	_d[0].X_mp_size = func() int32 {
		if (_d[0].X_mp_size) < int32(0) {
			return (-_dn)
		}
		return _dn
	}()
}

func _mpz_abs_sub_bit(tls *crt.TLS, _d *[1]Xmpz_srcptr, _bit_index uint32) {
	var _dn, _limb_index int32
	var _bit, _1___cy uint32
	var _dp *uint32
	_dn = func() int32 {
		if (_d[0].X_mp_size) >= int32(0) {
			return (_d[0].X_mp_size)
		}
		return (-(_d[0].X_mp_size))
	}()
	_dp = _d[0].X_mp_d
	_limb_index = int32(_bit_index / uint32(32))
	_bit = uint32(1) << uint(int32(_bit_index%uint32(32)))

	_1___cy = Xmpn_sub_1(tls, elem0(_dp, uintptr(_limb_index)), elem0(_dp, uintptr(_limb_index)), _dn-_limb_index, _bit)

	_dn = _mpn_normalized_size(tls, _dp, _dn)
	_d[0].X_mp_size = func() int32 {
		if (_d[0].X_mp_size) < int32(0) {
			return (-_dn)
		}
		return _dn
	}()
	_ = _1___cy
}

func Xmpz_sizeinbase(tls *crt.TLS, _u *[1]Xmpz_srcptr, _base int32) (r0 uint32) {
	var _un int32
	var _bits, _ndigits uint32
	var _up, _tp *uint32
	var _bi Tgmp_div_inverse

	_un = func() int32 {
		if (_u[0].X_mp_size) >= int32(0) {
			return (_u[0].X_mp_size)
		}
		return (-(_u[0].X_mp_size))
	}()
	if _un == int32(0) {
		return uint32(1)
	}
	_up = _u[0].X_mp_d
	_bits = (uint32(_un-int32(1)) * uint32(32)) + _mpn_limb_size_in_base_2(tls, *elem0(_up, uintptr(_un-int32(1))))
	switch _base {
	case int32(2):
		goto _4
	case int32(4):
		goto _5
	case int32(8):
		goto _6
	case int32(16):
		goto _7
	case int32(32):
		goto _8
	default:
		goto _9
	}

_4:
	return _bits

_5:
	return (_bits + uint32(1)) / uint32(2)

_6:
	return (_bits + uint32(2)) / uint32(3)

_7:
	return (_bits + uint32(3)) / uint32(4)

_8:
	return (_bits + uint32(4)) / uint32(5)

_9:
	_tp = _gmp_xalloc_limbs(tls, _un)
	Xmpn_copyi(tls, _tp, _up, _un)
	_mpn_div_qr_1_invert(tls, &_bi, uint32(_base))
	_ndigits = 0
_10:
	_ndigits += 1
	_mpn_div_qr_1_preinv(tls, _tp, _tp, _un, &_bi)
	_un -= bool2int((*elem0(_tp, uintptr(_un-int32(1)))) == 0)
	if _un > int32(0) {
		goto _10
	}
	_gmp_free_func(tls, unsafe.Pointer(_tp), 0)
	return _ndigits
}

func _mpn_limb_size_in_base_2(tls *crt.TLS, _u uint32) (r0 uint32) {
	var _shift, _1___clz_x, _1___clz_c uint32

	_1___clz_x = _u
	_1___clz_c = 0
_1:
	if (_1___clz_x & uint32(4278190080)) != 0 {
		goto _4
	}
	_1___clz_x <<= 8
	_1___clz_c += uint32(8)
	goto _1
_4:
	if (_1___clz_x & uint32(2147483648)) != 0 {
		goto _8
	}
	_1___clz_x <<= 1
	_1___clz_c += 1
	goto _4
_8:
	_shift = _1___clz_c
	return uint32(32) - _shift
}

func _mpn_div_qr_1_invert(tls *crt.TLS, _inv *Tgmp_div_inverse, _d uint32) {
	var _shift, _1___clz_x, _1___clz_c uint32

	_1___clz_x = _d
	_1___clz_c = 0
_1:
	if (_1___clz_x & uint32(4278190080)) != 0 {
		goto _4
	}
	_1___clz_x <<= 8
	_1___clz_c += uint32(8)
	goto _1
_4:
	if (_1___clz_x & uint32(2147483648)) != 0 {
		goto _8
	}
	_1___clz_x <<= 1
	_1___clz_c += 1
	goto _4
_8:
	_shift = _1___clz_c
	_inv.Xshift = _shift
	_inv.Xd1 = _d << uint(int32(_shift))
	_inv.Xdi = Xmpn_invert_3by2(tls, _inv.Xd1, 0)
}

// C comment
//  /* The 3/2 inverse is defined as
//
//       m = floor( (B^3-1) / (B u1 + u0)) - B
//  */
func Xmpn_invert_3by2(tls *crt.TLS, _u1 uint32, _u0 uint32) (r0 uint32) {
	var _r, _p, _m, _ql, _ul, _uh, _qh, _5_th, _5_tl, _8___x0, _8___x1, _8___x2, _8___x3, _8___ul, _8___vl, _8___uh, _8___vh, _8___u, _8___v uint32

	_ul = _u1 & uint32(65535)
	_uh = _u1 >> 16
	_qh = (^_u1) / _uh
	_r = (((^_u1) - (_qh * _uh)) << 16) | uint32(65535)
	_p = _qh * _ul
	if _r >= _p {
		goto _0
	}
	_qh -= 1
	_r += _u1
	if _r < _u1 {
		goto _2
	}
	if _r < _p {
		_qh -= 1
		_r += _u1
	}
_2:
_0:
	_r -= _p
	_p = ((_r >> 16) * _qh) + _r
	_ql = (_p >> 16) + uint32(1)
	_r = ((_r << 16) + uint32(65535)) - (_ql * _u1)
	if _r >= (_p << 16) {
		_ql -= 1
		_r += _u1
	}
	_m = (_qh << 16) + _ql
	if _r >= _u1 {
		_m += 1
		_r -= _u1
	}
	if _u0 <= 0 {
		goto _5
	}
	_r = ^_r
	_r += _u0
	if _r >= _u0 {
		goto _6
	}
	_m -= 1
	if _r >= _u1 {
		_m -= 1
		_r -= _u1
	}
	_r -= _u1
_6:
	_8___u = _u0
	_8___v = _m
	_8___ul = _8___u & uint32(65535)
	_8___uh = _8___u >> 16
	_8___vl = _8___v & uint32(65535)
	_8___vh = _8___v >> 16
	_8___x0 = _8___ul * _8___vl
	_8___x1 = _8___ul * _8___vh
	_8___x2 = _8___uh * _8___vl
	_8___x3 = _8___uh * _8___vh
	_8___x1 += _8___x0 >> 16
	_8___x1 += _8___x2
	if _8___x1 < _8___x2 {
		_8___x3 += uint32(65536)
	}
	_5_th = _8___x3 + (_8___x1 >> 16)
	_5_tl = (_8___x1 << 16) + (_8___x0 & uint32(65535))
	_r += _5_th
	if _r < _5_th {
		_m -= 1
		_m -= uint32(bool2int(_r > _u1) | (bool2int(_r == _u1) & bool2int(_5_tl > _u0)))
	}
_5:
	return _m
}

// C comment
//  /* Not matching current public gmp interface, rather corresponding to
//     the sbpi1_div_* functions. */
func _mpn_div_qr_1_preinv(tls *crt.TLS, _qp *uint32, _np *uint32, _nn int32, _inv *Tgmp_div_inverse) (r0 uint32) {
	var _d, _di, _r, _2_q, _3__qh, _3__ql, _3__r, _3__mask, _4___x0, _4___x1, _4___x2, _4___x3, _4___ul, _4___vl, _4___uh, _4___vh, _4___u, _4___v, _5___x uint32
	var _tp *uint32
	_tp = nil
	if _inv.Xshift > 0 {
		_tp = _gmp_xalloc_limbs(tls, _nn)
		_r = Xmpn_lshift(tls, _tp, _np, _nn, _inv.Xshift)
		_np = _tp
		goto _1
	}
	_r = 0
_1:
	_d = _inv.Xd1
	_di = _inv.Xdi
_2:
	if preInc1(&_nn, -1) < int32(0) {
		goto _3
	}
	_4___u = _r
	_4___v = _di
	_4___ul = _4___u & uint32(65535)
	_4___uh = _4___u >> 16
	_4___vl = _4___v & uint32(65535)
	_4___vh = _4___v >> 16
	_4___x0 = _4___ul * _4___vl
	_4___x1 = _4___ul * _4___vh
	_4___x2 = _4___uh * _4___vl
	_4___x3 = _4___uh * _4___vh
	_4___x1 += _4___x0 >> 16
	_4___x1 += _4___x2
	if _4___x1 < _4___x2 {
		_4___x3 += uint32(65536)
	}
	_3__qh = _4___x3 + (_4___x1 >> 16)
	_3__ql = (_4___x1 << 16) + (_4___x0 & uint32(65535))
	_5___x = _3__ql + (*elem0(_np, uintptr(_nn)))
	_3__qh = (_3__qh + (_r + uint32(1))) + uint32(bool2int(_5___x < _3__ql))
	_3__ql = _5___x
	_3__r = (*elem0(_np, uintptr(_nn))) - (_3__qh * _d)
	_3__mask = -uint32(bool2int(_3__r > _3__ql))
	_3__qh += _3__mask
	_3__r += _3__mask & _d
	if _3__r >= _d {
		_3__r -= _d
		_3__qh += 1
	}
	_r = _3__r
	_2_q = _3__qh
	if _qp != nil {
		*elem0(_qp, uintptr(_nn)) = _2_q
	}
	goto _2
_3:
	if _inv.Xshift > 0 {
		_gmp_free_func(tls, unsafe.Pointer(_tp), 0)
	}
	return _r >> uint(int32(_inv.Xshift))
}

func Xmpn_lshift(tls *crt.TLS, _rp *uint32, _up *uint32, _n int32, _cnt uint32) (r0 uint32) {
	var _high_limb, _low_limb, _tnc, _retval uint32

	*(*uintptr)(unsafe.Pointer(&_up)) += 4 * uintptr(_n)
	*(*uintptr)(unsafe.Pointer(&_rp)) += 4 * uintptr(_n)
	_tnc = uint32(32) - _cnt
	_low_limb = *preInc0(&_up, -4)
	_retval = _low_limb >> uint(int32(_tnc))
	_high_limb = _low_limb << uint(int32(_cnt))
_0:
	if preInc1(&_n, -1) != int32(0) {
		_low_limb = *preInc0(&_up, -4)
		*preInc0(&_rp, -4) = _high_limb | (_low_limb >> uint(int32(_tnc)))
		_high_limb = _low_limb << uint(int32(_cnt))
		goto _0
	}
	*preInc0(&_rp, -4) = _high_limb
	return _retval
}

func Xmpz_swap(tls *crt.TLS, _u *[1]Xmpz_srcptr, _v *[1]Xmpz_srcptr) {
	var _1___mp_size_t_swap__tmp, _2___mp_size_t_swap__tmp int32
	var _3___mp_ptr_swap__tmp *uint32
	_1___mp_size_t_swap__tmp = _u[0].X_mp_size
	_u[0].X_mp_size = _v[0].X_mp_size
	_v[0].X_mp_size = _1___mp_size_t_swap__tmp
	_2___mp_size_t_swap__tmp = _u[0].X_mp_alloc
	_u[0].X_mp_alloc = _v[0].X_mp_alloc
	_v[0].X_mp_alloc = _2___mp_size_t_swap__tmp
	_3___mp_ptr_swap__tmp = _u[0].X_mp_d
	_u[0].X_mp_d = _v[0].X_mp_d
	_v[0].X_mp_d = _3___mp_ptr_swap__tmp
}

func Xmpz_tdiv_q(tls *crt.TLS, _q *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d *[1]Xmpz_srcptr) {
	_mpz_div_qr(tls, _q, nil, _n, _d, int32(2))
}

// C comment
//  /* Allows q or r to be zero. Returns 1 iff remainder is non-zero. */
func _mpz_div_qr(tls *crt.TLS, _q *[1]Xmpz_srcptr, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d *[1]Xmpz_srcptr, _mode int32) (r0 int32) {
	var _ns, _ds, _nn, _dn, _qs, _6_qn, _6_rn int32
	var _6_np, _6_qp *uint32
	var _6_tq, _6_tr [1]Xmpz_srcptr
	_ns = _n[0].X_mp_size
	_ds = _d[0].X_mp_size
	if _ds == int32(0) {
		_gmp_die(tls, str(170))
	}
	if _ns != int32(0) {
		goto _1
	}
	if _q != nil {
		_q[0].X_mp_size = int32(0)
	}
	if _r != nil {
		_r[0].X_mp_size = int32(0)
	}
	return int32(0)

_1:
	_nn = func() int32 {
		if _ns >= int32(0) {
			return _ns
		}
		return (-_ns)
	}()
	_dn = func() int32 {
		if _ds >= int32(0) {
			return _ds
		}
		return (-_ds)
	}()
	_qs = _ds ^ _ns
	if _nn >= _dn {
		goto _8
	}
	if _mode != int32(1) || _qs < int32(0) {
		goto _10
	}
	if _r != nil {
		Xmpz_sub(tls, _r, _n, _d)
	}
	if _q != nil {
		Xmpz_set_ui(tls, _q, uint32(1))
	}
	goto _18
_10:
	if _mode != int32(0) || _qs >= int32(0) {
		goto _15
	}
	if _r != nil {
		Xmpz_add(tls, _r, _n, _d)
	}
	if _q != nil {
		Xmpz_set_si(tls, _q, int32(-1))
	}
	goto _18
_15:
	if _r != nil {
		Xmpz_set(tls, _r, _n)
	}
	if _q != nil {
		_q[0].X_mp_size = int32(0)
	}
_18:
	return int32(1)

_8:
	Xmpz_init_set(tls, &_6_tr, _n)
	_6_np = _6_tr[0].X_mp_d
	_6_qn = (_nn - _dn) + int32(1)
	if _q != nil {
		Xmpz_init2(tls, &_6_tq, uint32(_6_qn)*uint32(32))
		_6_qp = _6_tq[0].X_mp_d
		goto _23
	}
	_6_qp = nil
_23:
	_mpn_div_qr(tls, _6_qp, _6_np, _nn, _d[0].X_mp_d, _dn)
	if _6_qp != nil {
		_6_qn -= bool2int((*elem0(_6_qp, uintptr(_6_qn-int32(1)))) == 0)
		_6_tq[0].X_mp_size = func() int32 {
			if _qs < int32(0) {
				return (-_6_qn)
			}
			return _6_qn
		}()
	}
	_6_rn = _mpn_normalized_size(tls, _6_np, _dn)
	_6_tr[0].X_mp_size = func() int32 {
		if _ns < int32(0) {
			return (-_6_rn)
		}
		return _6_rn
	}()
	if _mode != int32(0) || _qs >= int32(0) || _6_rn == int32(0) {
		goto _31
	}
	if _q != nil {
		Xmpz_sub_ui(tls, &_6_tq, &_6_tq, uint32(1))
	}
	if _r != nil {
		Xmpz_add(tls, &_6_tr, &_6_tr, _d)
	}
	goto _37
_31:
	if _mode != int32(1) || _qs < int32(0) || _6_rn == int32(0) {
		goto _37
	}
	if _q != nil {
		Xmpz_add_ui(tls, &_6_tq, &_6_tq, uint32(1))
	}
	if _r != nil {
		Xmpz_sub(tls, &_6_tr, &_6_tr, _d)
	}
_37:
	if _q != nil {
		Xmpz_swap(tls, &_6_tq, _q)
		Xmpz_clear(tls, &_6_tq)
	}
	if _r != nil {
		Xmpz_swap(tls, &_6_tr, _r)
	}
	Xmpz_clear(tls, &_6_tr)
	return bool2int(_6_rn != int32(0))
}

func Xmpz_sub(tls *crt.TLS, _r *[1]Xmpz_srcptr, _a *[1]Xmpz_srcptr, _b *[1]Xmpz_srcptr) {
	var _rn int32
	if ((_a[0].X_mp_size) ^ (_b[0].X_mp_size)) >= int32(0) {
		_rn = _mpz_abs_sub(tls, _r, _a, _b)
		goto _1
	}
	_rn = _mpz_abs_add(tls, _r, _a, _b)
_1:
	_r[0].X_mp_size = func() int32 {
		if (_a[0].X_mp_size) >= int32(0) {
			return _rn
		}
		return (-_rn)
	}()
}

func _mpz_abs_sub(tls *crt.TLS, _r *[1]Xmpz_srcptr, _a *[1]Xmpz_srcptr, _b *[1]Xmpz_srcptr) (r0 int32) {
	var _an, _bn, _cmp int32
	var _2___cy, _4___cy uint32
	var _rp *uint32
	_an = func() int32 {
		if (_a[0].X_mp_size) >= int32(0) {
			return (_a[0].X_mp_size)
		}
		return (-(_a[0].X_mp_size))
	}()
	_bn = func() int32 {
		if (_b[0].X_mp_size) >= int32(0) {
			return (_b[0].X_mp_size)
		}
		return (-(_b[0].X_mp_size))
	}()
	_cmp = _mpn_cmp4(tls, _a[0].X_mp_d, _an, _b[0].X_mp_d, _bn)
	if _cmp <= int32(0) {
		goto _4
	}
	_rp = func() *uint32 {
		if _an > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _an)
		}
		return (_r[0].X_mp_d)
	}()
	_2___cy = Xmpn_sub(tls, _rp, _a[0].X_mp_d, _an, _b[0].X_mp_d, _bn)
	return _mpn_normalized_size(tls, _rp, _an)

_4:
	if _cmp >= int32(0) {
		goto _9
	}
	_rp = func() *uint32 {
		if _bn > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _bn)
		}
		return (_r[0].X_mp_d)
	}()
	_4___cy = Xmpn_sub(tls, _rp, _b[0].X_mp_d, _bn, _a[0].X_mp_d, _an)
	return -_mpn_normalized_size(tls, _rp, _bn)

_9:
	return int32(0)

	_ = _2___cy
	_ = _4___cy
	panic(0)
}

func _mpn_cmp4(tls *crt.TLS, _ap *uint32, _an int32, _bp *uint32, _bn int32) (r0 int32) {
	if _an != _bn {
		return func() int32 {
			if _an < _bn {
				return int32(-1)
			}
			return int32(1)
		}()
	}
	return Xmpn_cmp(tls, _ap, _bp, _an)
}

func _mpz_abs_add(tls *crt.TLS, _r *[1]Xmpz_srcptr, _a *[1]Xmpz_srcptr, _b *[1]Xmpz_srcptr) (r0 int32) {
	var _an, _bn, _3___mp_size_t_swap__tmp int32
	var _cy uint32
	var _rp *uint32
	var _2___mpz_srcptr_swap__tmp *Xmpz_srcptr
	_an = func() int32 {
		if (_a[0].X_mp_size) >= int32(0) {
			return (_a[0].X_mp_size)
		}
		return (-(_a[0].X_mp_size))
	}()
	_bn = func() int32 {
		if (_b[0].X_mp_size) >= int32(0) {
			return (_b[0].X_mp_size)
		}
		return (-(_b[0].X_mp_size))
	}()
	if _an >= _bn {
		goto _4
	}
	_2___mpz_srcptr_swap__tmp = &_a[0]
	_a = _b
	_b = (*[1]Xmpz_srcptr)(unsafe.Pointer(_2___mpz_srcptr_swap__tmp))
	_3___mp_size_t_swap__tmp = _an
	_an = _bn
	_bn = _3___mp_size_t_swap__tmp
_4:
	_rp = func() *uint32 {
		if (_an + int32(1)) > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _an+int32(1))
		}
		return (_r[0].X_mp_d)
	}()
	_cy = Xmpn_add(tls, _rp, _a[0].X_mp_d, _an, _b[0].X_mp_d, _bn)
	*elem0(_rp, uintptr(_an)) = _cy
	return int32(uint32(_an) + _cy)
}

func Xmpz_set_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _x uint32) {
	if _x > 0 {
		_r[0].X_mp_size = int32(1)
		*func() *uint32 {
			if int32(1) > (_r[0].X_mp_alloc) {
				return _mpz_realloc(tls, _r, int32(1))
			}
			return (_r[0].X_mp_d)
		}() = _x
		goto _3
	}
	_r[0].X_mp_size = int32(0)
_3:
}

func Xmpz_add(tls *crt.TLS, _r *[1]Xmpz_srcptr, _a *[1]Xmpz_srcptr, _b *[1]Xmpz_srcptr) {
	var _rn int32
	if ((_a[0].X_mp_size) ^ (_b[0].X_mp_size)) >= int32(0) {
		_rn = _mpz_abs_add(tls, _r, _a, _b)
		goto _1
	}
	_rn = _mpz_abs_sub(tls, _r, _a, _b)
_1:
	_r[0].X_mp_size = func() int32 {
		if (_a[0].X_mp_size) >= int32(0) {
			return _rn
		}
		return (-_rn)
	}()
}

// C comment
//  /* MPZ assignment and basic conversions. */
func Xmpz_set_si(tls *crt.TLS, _r *[1]Xmpz_srcptr, _x int32) {
	if _x >= int32(0) {
		Xmpz_set_ui(tls, _r, uint32(_x))
		goto _1
	}
	_r[0].X_mp_size = int32(-1)
	*func() *uint32 {
		if int32(1) > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, int32(1))
		}
		return (_r[0].X_mp_d)
	}() = -(uint32(_x+int32(1)) - uint32(1))
_1:
}

func Xmpz_init_set(tls *crt.TLS, _r *[1]Xmpz_srcptr, _x *[1]Xmpz_srcptr) {
	Xmpz_init(tls, _r)
	Xmpz_set(tls, _r, _x)
}

// C comment
//  /* The utility of this function is a bit limited, since many functions
//     assigns the result variable using mpz_swap. */
func Xmpz_init2(tls *crt.TLS, _r *[1]Xmpz_srcptr, _bits uint32) {
	var _rn int32
	_bits -= uint32(bool2int(_bits != 0))
	_rn = int32(uint32(1) + (_bits / uint32(32)))
	_r[0].X_mp_alloc = _rn
	_r[0].X_mp_size = int32(0)
	_r[0].X_mp_d = _gmp_xalloc_limbs(tls, _rn)
}

func _mpn_div_qr(tls *crt.TLS, _qp *uint32, _np *uint32, _nn int32, _dp *uint32, _dn int32) {
	var _2___cy uint32
	var _tp *uint32
	var _inv Tgmp_div_inverse
	_tp = nil

	_mpn_div_qr_invert(tls, &_inv, _dp, _dn)
	if _dn <= int32(2) || _inv.Xshift <= 0 {
		goto _1
	}
	_tp = _gmp_xalloc_limbs(tls, _dn)
	_2___cy = Xmpn_lshift(tls, _tp, _dp, _dn, _inv.Xshift)

	_dp = _tp
_1:
	_mpn_div_qr_preinv(tls, _qp, _np, _nn, _dp, _dn, &_inv)
	if _tp != nil {
		_gmp_free_func(tls, unsafe.Pointer(_tp), 0)
	}
	_ = _2___cy
}

func _mpn_div_qr_invert(tls *crt.TLS, _inv *Tgmp_div_inverse, _dp *uint32, _dn int32) {
	var _1_shift, _1_d1, _1_d0, _2___clz_x, _2___clz_c uint32

	if _dn == int32(1) {
		_mpn_div_qr_1_invert(tls, _inv, *_dp)
		goto _3
	}
	if _dn == int32(2) {
		_mpn_div_qr_2_invert(tls, _inv, *elem0(_dp, uintptr(1)), *_dp)
		goto _3
	}
	_1_d1 = *elem0(_dp, uintptr(_dn-int32(1)))
	_1_d0 = *elem0(_dp, uintptr(_dn-int32(2)))

	_2___clz_x = _1_d1
	_2___clz_c = 0
_5:
	if (_2___clz_x & uint32(4278190080)) != 0 {
		goto _8
	}
	_2___clz_x <<= 8
	_2___clz_c += uint32(8)
	goto _5
_8:
	if (_2___clz_x & uint32(2147483648)) != 0 {
		goto _12
	}
	_2___clz_x <<= 1
	_2___clz_c += 1
	goto _8
_12:
	_1_shift = _2___clz_c
	_inv.Xshift = _1_shift
	if _1_shift > 0 {
		_1_d1 = (_1_d1 << uint(int32(_1_shift))) | (_1_d0 >> uint(int32(uint32(32)-_1_shift)))
		_1_d0 = (_1_d0 << uint(int32(_1_shift))) | ((*elem0(_dp, uintptr(_dn-int32(3)))) >> uint(int32(uint32(32)-_1_shift)))
	}
	_inv.Xd1 = _1_d1
	_inv.Xd0 = _1_d0
	_inv.Xdi = Xmpn_invert_3by2(tls, _1_d1, _1_d0)
_3:
}

func _mpn_div_qr_2_invert(tls *crt.TLS, _inv *Tgmp_div_inverse, _d1 uint32, _d0 uint32) {
	var _shift, _1___clz_x, _1___clz_c uint32

	_1___clz_x = _d1
	_1___clz_c = 0
_1:
	if (_1___clz_x & uint32(4278190080)) != 0 {
		goto _4
	}
	_1___clz_x <<= 8
	_1___clz_c += uint32(8)
	goto _1
_4:
	if (_1___clz_x & uint32(2147483648)) != 0 {
		goto _8
	}
	_1___clz_x <<= 1
	_1___clz_c += 1
	goto _4
_8:
	_shift = _1___clz_c
	_inv.Xshift = _shift
	if _shift > 0 {
		_d1 = (_d1 << uint(int32(_shift))) | (_d0 >> uint(int32(uint32(32)-_shift)))
		_d0 <<= uint(int32(_shift))
	}
	_inv.Xd1 = _d1
	_inv.Xd0 = _d0
	_inv.Xdi = Xmpn_invert_3by2(tls, _d1, _d0)
}

func _mpn_div_qr_preinv(tls *crt.TLS, _qp *uint32, _np *uint32, _nn int32, _dp *uint32, _dn int32, _inv *Tgmp_div_inverse) {
	var _1_nh, _1_shift, _2___cy uint32

	if _dn == int32(1) {
		*_np = _mpn_div_qr_1_preinv(tls, _qp, _np, _nn, _inv)
		goto _3
	}
	if _dn == int32(2) {
		_mpn_div_qr_2_preinv(tls, _qp, _np, _np, _nn, _inv)
		goto _3
	}

	_1_shift = _inv.Xshift
	if _1_shift > 0 {
		_1_nh = Xmpn_lshift(tls, _np, _np, _nn, _1_shift)
		goto _5
	}
	_1_nh = 0
_5:
	_mpn_div_qr_pi1(tls, _qp, _np, _nn, _1_nh, _dp, _dn, _inv.Xdi)
	if _1_shift <= 0 {
		goto _6
	}
	_2___cy = Xmpn_rshift(tls, _np, _np, _dn, _1_shift)

_6:
_3:
	_ = _2___cy
}

func _mpn_div_qr_2_preinv(tls *crt.TLS, _qp *uint32, _rp *uint32, _np *uint32, _nn int32, _inv *Tgmp_div_inverse) {
	var _i int32
	var _shift, _d1, _d0, _di, _r1, _r0, _2_n0, _2_q, _3__q0, _3__t1, _3__t0, _3__mask, _4___x0, _4___x1, _4___x2, _4___x3, _4___ul, _4___vl, _4___uh, _4___vh, _4___u, _4___v, _5___x, _6___x, _7___x0, _7___x1, _7___x2, _7___x3, _7___ul, _7___vl, _7___uh, _7___vh, _7___u, _7___v, _8___x, _9___x, _12___x uint32
	var _tp *uint32

	_shift = _inv.Xshift
	_d1 = _inv.Xd1
	_d0 = _inv.Xd0
	_di = _inv.Xdi
	if _shift > 0 {
		_tp = _gmp_xalloc_limbs(tls, _nn)
		_r1 = Xmpn_lshift(tls, _tp, _np, _nn, _shift)
		_np = _tp
		goto _1
	}
	_r1 = 0
_1:
	_r0 = *elem0(_np, uintptr(_nn-int32(1)))
	_i = _nn - int32(2)
_2:
	_2_n0 = *elem0(_np, uintptr(_i))
	_4___u = _r1
	_4___v = _di
	_4___ul = _4___u & uint32(65535)
	_4___uh = _4___u >> 16
	_4___vl = _4___v & uint32(65535)
	_4___vh = _4___v >> 16
	_4___x0 = _4___ul * _4___vl
	_4___x1 = _4___ul * _4___vh
	_4___x2 = _4___uh * _4___vl
	_4___x3 = _4___uh * _4___vh
	_4___x1 += _4___x0 >> 16
	_4___x1 += _4___x2
	if _4___x1 < _4___x2 {
		_4___x3 += uint32(65536)
	}
	_2_q = _4___x3 + (_4___x1 >> 16)
	_3__q0 = (_4___x1 << 16) + (_4___x0 & uint32(65535))
	_5___x = _3__q0 + _r0
	_2_q = (_2_q + _r1) + uint32(bool2int(_5___x < _3__q0))
	_3__q0 = _5___x
	_r1 = _r0 - (_d1 * _2_q)
	_6___x = _2_n0 - _d0
	_r1 = (_r1 - _d1) - uint32(bool2int(_2_n0 < _d0))
	_r0 = _6___x
	_7___u = _d0
	_7___v = _2_q
	_7___ul = _7___u & uint32(65535)
	_7___uh = _7___u >> 16
	_7___vl = _7___v & uint32(65535)
	_7___vh = _7___v >> 16
	_7___x0 = _7___ul * _7___vl
	_7___x1 = _7___ul * _7___vh
	_7___x2 = _7___uh * _7___vl
	_7___x3 = _7___uh * _7___vh
	_7___x1 += _7___x0 >> 16
	_7___x1 += _7___x2
	if _7___x1 < _7___x2 {
		_7___x3 += uint32(65536)
	}
	_3__t1 = _7___x3 + (_7___x1 >> 16)
	_3__t0 = (_7___x1 << 16) + (_7___x0 & uint32(65535))
	_8___x = _r0 - _3__t0
	_r1 = (_r1 - _3__t1) - uint32(bool2int(_r0 < _3__t0))
	_r0 = _8___x
	_2_q += 1
	_3__mask = -uint32(bool2int(_r1 >= _3__q0))
	_2_q += _3__mask
	_9___x = _r0 + (_3__mask & _d0)
	_r1 = (_r1 + (_3__mask & _d1)) + uint32(bool2int(_9___x < _r0))
	_r0 = _9___x
	if _r1 < _d1 {
		goto _12
	}
	if _r1 <= _d1 && _r0 < _d0 {
		goto _14
	}
	_2_q += 1
	_12___x = _r0 - _d0
	_r1 = (_r1 - _d1) - uint32(bool2int(_r0 < _d0))
	_r0 = _12___x
_14:
_12:
	if _qp != nil {
		*elem0(_qp, uintptr(_i)) = _2_q
	}
	if preInc1(&_i, -1) >= int32(0) {
		goto _2
	}
	if _shift > 0 {
		_r0 = (_r0 >> uint(int32(_shift))) | (_r1 << uint(int32(uint32(32)-_shift)))
		_r1 >>= uint(int32(_shift))
		_gmp_free_func(tls, unsafe.Pointer(_tp), 0)
	}
	*elem0(_rp, uintptr(1)) = _r1
	*_rp = _r0
}

func _mpn_div_qr_pi1(tls *crt.TLS, _qp *uint32, _np *uint32, _nn int32, _n1 uint32, _dp *uint32, _dn int32, _dinv uint32) {
	var _i int32
	var _d1, _d0, _cy, _cy1, _q, _1_n0, _4__q0, _4__t1, _4__t0, _4__mask, _5___x0, _5___x1, _5___x2, _5___x3, _5___ul, _5___vl, _5___uh, _5___vh, _5___u, _5___v, _6___x, _7___x, _8___x0, _8___x1, _8___x2, _8___x3, _8___ul, _8___vl, _8___uh, _8___vh, _8___u, _8___v, _9___x, _10___x, _13___x uint32

	_d1 = *elem0(_dp, uintptr(_dn-int32(1)))
	_d0 = *elem0(_dp, uintptr(_dn-int32(2)))

	_i = _nn - _dn
_0:
	_1_n0 = *elem0(_np, uintptr((_dn-int32(1))+_i))
	if (_n1 == _d1) && (_1_n0 == _d0) {
		_q = uint32(4294967295)
		Xmpn_submul_1(tls, elem0(_np, uintptr(_i)), _dp, _dn, _q)
		_n1 = *elem0(_np, uintptr((_dn-int32(1))+_i))
		goto _3
	}
	_5___u = _n1
	_5___v = _dinv
	_5___ul = _5___u & uint32(65535)
	_5___uh = _5___u >> 16
	_5___vl = _5___v & uint32(65535)
	_5___vh = _5___v >> 16
	_5___x0 = _5___ul * _5___vl
	_5___x1 = _5___ul * _5___vh
	_5___x2 = _5___uh * _5___vl
	_5___x3 = _5___uh * _5___vh
	_5___x1 += _5___x0 >> 16
	_5___x1 += _5___x2
	if _5___x1 < _5___x2 {
		_5___x3 += uint32(65536)
	}
	_q = _5___x3 + (_5___x1 >> 16)
	_4__q0 = (_5___x1 << 16) + (_5___x0 & uint32(65535))
	_6___x = _4__q0 + _1_n0
	_q = (_q + _n1) + uint32(bool2int(_6___x < _4__q0))
	_4__q0 = _6___x
	_n1 = _1_n0 - (_d1 * _q)
	_7___x = (*elem0(_np, uintptr((_dn-int32(2))+_i))) - _d0
	_n1 = (_n1 - _d1) - uint32(bool2int((*elem0(_np, uintptr((_dn-int32(2))+_i))) < _d0))
	_1_n0 = _7___x
	_8___u = _d0
	_8___v = _q
	_8___ul = _8___u & uint32(65535)
	_8___uh = _8___u >> 16
	_8___vl = _8___v & uint32(65535)
	_8___vh = _8___v >> 16
	_8___x0 = _8___ul * _8___vl
	_8___x1 = _8___ul * _8___vh
	_8___x2 = _8___uh * _8___vl
	_8___x3 = _8___uh * _8___vh
	_8___x1 += _8___x0 >> 16
	_8___x1 += _8___x2
	if _8___x1 < _8___x2 {
		_8___x3 += uint32(65536)
	}
	_4__t1 = _8___x3 + (_8___x1 >> 16)
	_4__t0 = (_8___x1 << 16) + (_8___x0 & uint32(65535))
	_9___x = _1_n0 - _4__t0
	_n1 = (_n1 - _4__t1) - uint32(bool2int(_1_n0 < _4__t0))
	_1_n0 = _9___x
	_q += 1
	_4__mask = -uint32(bool2int(_n1 >= _4__q0))
	_q += _4__mask
	_10___x = _1_n0 + (_4__mask & _d0)
	_n1 = (_n1 + (_4__mask & _d1)) + uint32(bool2int(_10___x < _1_n0))
	_1_n0 = _10___x
	if _n1 < _d1 {
		goto _13
	}
	if _n1 <= _d1 && _1_n0 < _d0 {
		goto _15
	}
	_q += 1
	_13___x = _1_n0 - _d0
	_n1 = (_n1 - _d1) - uint32(bool2int(_1_n0 < _d0))
	_1_n0 = _13___x
_15:
_13:
	_cy = Xmpn_submul_1(tls, elem0(_np, uintptr(_i)), _dp, _dn-int32(2), _q)
	_cy1 = uint32(bool2int(_1_n0 < _cy))
	_1_n0 = _1_n0 - _cy
	_cy = uint32(bool2int(_n1 < _cy1))
	_n1 = _n1 - _cy1
	*elem0(_np, uintptr((_dn-int32(2))+_i)) = _1_n0
	if _cy != 0 {
		_n1 += _d1 + Xmpn_add_n(tls, elem0(_np, uintptr(_i)), elem0(_np, uintptr(_i)), _dp, _dn-int32(1))
		_q -= 1
	}
_3:
	if _qp != nil {
		*elem0(_qp, uintptr(_i)) = _q
	}
	if preInc1(&_i, -1) >= int32(0) {
		goto _0
	}
	*elem0(_np, uintptr(_dn-int32(1))) = _n1
}

func Xmpn_rshift(tls *crt.TLS, _rp *uint32, _up *uint32, _n int32, _cnt uint32) (r0 uint32) {
	var _high_limb, _low_limb, _tnc, _retval uint32

	_tnc = uint32(32) - _cnt
	_high_limb = *postInc0(&_up, 4)
	_retval = _high_limb << uint(int32(_tnc))
	_low_limb = _high_limb >> uint(int32(_cnt))
_0:
	if preInc1(&_n, -1) != int32(0) {
		_high_limb = *postInc0(&_up, 4)
		*postInc0(&_rp, 4) = _low_limb | (_high_limb << uint(int32(_tnc)))
		_low_limb = _high_limb >> uint(int32(_cnt))
		goto _0
	}
	*_rp = _low_limb
	return _retval
}

func Xmpz_sub_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _a *[1]Xmpz_srcptr, _b uint32) {
	if (_a[0].X_mp_size) < int32(0) {
		_r[0].X_mp_size = -_mpz_abs_add_ui(tls, _r, _a, _b)
		goto _1
	}
	_r[0].X_mp_size = _mpz_abs_sub_ui(tls, _r, _a, _b)
_1:
}

// C comment
//  /* Adds to the absolute value. Returns new size, but doesn't store it. */
func _mpz_abs_add_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _a *[1]Xmpz_srcptr, _b uint32) (r0 int32) {
	var _an int32
	var _cy uint32
	var _rp *uint32
	_an = func() int32 {
		if (_a[0].X_mp_size) >= int32(0) {
			return (_a[0].X_mp_size)
		}
		return (-(_a[0].X_mp_size))
	}()
	if _an == int32(0) {
		*func() *uint32 {
			if int32(1) > (_r[0].X_mp_alloc) {
				return _mpz_realloc(tls, _r, int32(1))
			}
			return (_r[0].X_mp_d)
		}() = _b
		return bool2int(_b > 0)
	}
	_rp = func() *uint32 {
		if (_an + int32(1)) > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _an+int32(1))
		}
		return (_r[0].X_mp_d)
	}()
	_cy = Xmpn_add_1(tls, _rp, _a[0].X_mp_d, _an, _b)
	*elem0(_rp, uintptr(_an)) = _cy
	{
		p := &_an
		*p = int32(uint32(*p) + _cy)
	}
	return _an
}

// C comment
//  /* Subtract from the absolute value. Returns new size, (or -1 on underflow),
//     but doesn't store it. */
func _mpz_abs_sub_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _a *[1]Xmpz_srcptr, _b uint32) (r0 int32) {
	var _an int32
	var _4___cy uint32
	var _rp *uint32
	_an = func() int32 {
		if (_a[0].X_mp_size) >= int32(0) {
			return (_a[0].X_mp_size)
		}
		return (-(_a[0].X_mp_size))
	}()
	if _an == int32(0) {
		*func() *uint32 {
			if int32(1) > (_r[0].X_mp_alloc) {
				return _mpz_realloc(tls, _r, int32(1))
			}
			return (_r[0].X_mp_d)
		}() = _b
		return -bool2int(_b > 0)
	}
	_rp = func() *uint32 {
		if _an > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _an)
		}
		return (_r[0].X_mp_d)
	}()
	if (_an == int32(1)) && ((*(_a[0].X_mp_d)) < _b) {
		*_rp = _b - (*(_a[0].X_mp_d))
		return int32(-1)
	}
	_4___cy = Xmpn_sub_1(tls, _rp, _a[0].X_mp_d, _an, _b)
	return _mpn_normalized_size(tls, _rp, _an)

	_ = _4___cy
	panic(0)
}

func Xmpz_add_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _a *[1]Xmpz_srcptr, _b uint32) {
	if (_a[0].X_mp_size) >= int32(0) {
		_r[0].X_mp_size = _mpz_abs_add_ui(tls, _r, _a, _b)
		goto _1
	}
	_r[0].X_mp_size = -_mpz_abs_sub_ui(tls, _r, _a, _b)
_1:
}

func Xmpz_clear(tls *crt.TLS, _r *[1]Xmpz_srcptr) {
	if (_r[0].X_mp_alloc) != 0 {
		_gmp_free_func(tls, unsafe.Pointer(_r[0].X_mp_d), 0)
	}
}

func Xmpz_tdiv_q_2exp(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _cnt uint32) {
	_mpz_div_q_2exp(tls, _r, _u, _cnt, int32(2))
}

func _mpz_div_q_2exp(tls *crt.TLS, _q *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _bit_index uint32, _mode int32) {
	var _un, _qn, _limb_cnt, _adjust int32
	var _qp *uint32
	_un = _u[0].X_mp_size
	if _un == int32(0) {
		_q[0].X_mp_size = int32(0)
		return
	}
	_limb_cnt = int32(_bit_index / uint32(32))
	_qn = func() int32 {
		if _un >= int32(0) {
			return _un
		}
		return (-_un)
	}() - _limb_cnt
	_bit_index %= uint32(32)
	if _mode == func() int32 {
		if _un > int32(0) {
			return int32(1)
		}
		return int32(0)
	}() {
		_adjust = bool2int(((_qn <= int32(0)) || (Xmpn_zero_p(tls, _u[0].X_mp_d, _limb_cnt) == 0)) || (((*elem0(_u[0].X_mp_d, uintptr(_limb_cnt))) & ((uint32(1) << uint(int32(_bit_index))) - uint32(1))) != 0))
		goto _8
	}
	_adjust = int32(0)
_8:
	if _qn <= int32(0) {
		_qn = int32(0)
		goto _10
	}
	_qp = func() *uint32 {
		if _qn > (_q[0].X_mp_alloc) {
			return _mpz_realloc(tls, _q, _qn)
		}
		return (_q[0].X_mp_d)
	}()
	if _bit_index != 0 {
		Xmpn_rshift(tls, _qp, elem0(_u[0].X_mp_d, uintptr(_limb_cnt)), _qn, _bit_index)
		_qn -= bool2int((*elem0(_qp, uintptr(_qn-int32(1)))) == 0)
		goto _14
	}
	Xmpn_copyi(tls, _qp, elem0(_u[0].X_mp_d, uintptr(_limb_cnt)), _qn)
_14:
_10:
	_q[0].X_mp_size = _qn
	if _adjust != 0 {
		Xmpz_add_ui(tls, _q, _q, uint32(1))
	}
	if _un < int32(0) {
		Xmpz_neg(tls, _q, _q)
	}
}

func Xmpz_neg(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr) {
	Xmpz_set(tls, _r, _u)
	_r[0].X_mp_size = -(_r[0].X_mp_size)
}

func Xmpz_cmpabs(tls *crt.TLS, _u *[1]Xmpz_srcptr, _v *[1]Xmpz_srcptr) (r0 int32) {
	return _mpn_cmp4(tls, _u[0].X_mp_d, func() int32 {
		if (_u[0].X_mp_size) >= int32(0) {
			return (_u[0].X_mp_size)
		}
		return (-(_u[0].X_mp_size))
	}(), _v[0].X_mp_d, func() int32 {
		if (_v[0].X_mp_size) >= int32(0) {
			return (_v[0].X_mp_size)
		}
		return (-(_v[0].X_mp_size))
	}())
}

func Xmpz_pow_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _b *[1]Xmpz_srcptr, _e uint32) {
	var _bit uint32
	var _tr [1]Xmpz_srcptr
	Xmpz_init_set_ui(tls, &_tr, uint32(1))
	_bit = uint32(2147483648)
_0:
	Xmpz_mul(tls, &_tr, &_tr, &_tr)
	if (_e & _bit) != 0 {
		Xmpz_mul(tls, &_tr, &_tr, _b)
	}
	_bit >>= 1
	if _bit > 0 {
		goto _0
	}
	Xmpz_swap(tls, _r, &_tr)
	Xmpz_clear(tls, &_tr)
}

func Xmpz_init_set_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _x uint32) {
	Xmpz_init(tls, _r)
	Xmpz_set_ui(tls, _r, _x)
}

func Xmpz_mul(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v *[1]Xmpz_srcptr) {
	var _sign, _un, _vn, _rn int32
	var _tp *uint32
	var _t [1]Xmpz_srcptr
	_un = _u[0].X_mp_size
	_vn = _v[0].X_mp_size
	if (_un == int32(0)) || (_vn == int32(0)) {
		_r[0].X_mp_size = int32(0)
		return
	}
	_sign = bool2int((_un ^ _vn) < int32(0))
	_un = func() int32 {
		if _un >= int32(0) {
			return _un
		}
		return (-_un)
	}()
	_vn = func() int32 {
		if _vn >= int32(0) {
			return _vn
		}
		return (-_vn)
	}()
	Xmpz_init2(tls, &_t, uint32(_un+_vn)*uint32(32))
	_tp = _t[0].X_mp_d
	if _un >= _vn {
		Xmpn_mul(tls, _tp, _u[0].X_mp_d, _un, _v[0].X_mp_d, _vn)
		goto _7
	}
	Xmpn_mul(tls, _tp, _v[0].X_mp_d, _vn, _u[0].X_mp_d, _un)
_7:
	_rn = _un + _vn
	_rn -= bool2int((*elem0(_tp, uintptr(_rn-int32(1)))) == 0)
	_t[0].X_mp_size = func() int32 {
		if _sign != 0 {
			return (-_rn)
		}
		return _rn
	}()
	Xmpz_swap(tls, _r, &_t)
	Xmpz_clear(tls, &_t)
}

func Xmpz_mul_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v uint32) {
	var _un, _us int32
	var _cy uint32
	var _tp *uint32
	_us = _u[0].X_mp_size
	if (_us == int32(0)) || (_v == 0) {
		_r[0].X_mp_size = int32(0)
		return
	}
	_un = func() int32 {
		if _us >= int32(0) {
			return _us
		}
		return (-_us)
	}()
	_tp = func() *uint32 {
		if (_un + int32(1)) > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _un+int32(1))
		}
		return (_r[0].X_mp_d)
	}()
	_cy = Xmpn_mul_1(tls, _tp, _u[0].X_mp_d, _un, _v)
	*elem0(_tp, uintptr(_un)) = _cy
	_un += bool2int(_cy > 0)
	_r[0].X_mp_size = func() int32 {
		if _us < int32(0) {
			return (-_un)
		}
		return _un
	}()
}

func Xmpz_tdiv_q_ui(tls *crt.TLS, _q *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d uint32) (r0 uint32) {
	return _mpz_div_qr_ui(tls, _q, nil, _n, _d, int32(2))
}

func _mpz_div_qr_ui(tls *crt.TLS, _q *[1]Xmpz_srcptr, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d uint32, _mode int32) (r0 uint32) {
	var _ns, _qn, _rs int32
	var _rl, _3___cy uint32
	var _qp *uint32
	_ns = _n[0].X_mp_size
	if _ns != int32(0) {
		goto _0
	}
	if _q != nil {
		_q[0].X_mp_size = int32(0)
	}
	if _r != nil {
		_r[0].X_mp_size = int32(0)
	}
	return 0

_0:
	_qn = func() int32 {
		if _ns >= int32(0) {
			return _ns
		}
		return (-_ns)
	}()
	if _q != nil {
		_qp = func() *uint32 {
			if _qn > (_q[0].X_mp_alloc) {
				return _mpz_realloc(tls, _q, _qn)
			}
			return (_q[0].X_mp_d)
		}()
		goto _8
	}
	_qp = nil
_8:
	_rl = _mpn_div_qr_1(tls, _qp, _n[0].X_mp_d, _qn, _d)

	_rs = bool2int(_rl > 0)
	_rs = func() int32 {
		if _ns < int32(0) {
			return (-_rs)
		}
		return _rs
	}()
	if _rl <= 0 || (_mode != int32(0) || _ns >= int32(0)) && (_mode != int32(1) || _ns < int32(0)) {
		goto _15
	}
	if _q == nil {
		goto _16
	}
	_3___cy = Xmpn_add_1(tls, _qp, _qp, _qn, uint32(1))

_16:
	_rl = _d - _rl
	_rs = -_rs
_15:
	if _r != nil {
		*func() *uint32 {
			if int32(1) > (_r[0].X_mp_alloc) {
				return _mpz_realloc(tls, _r, int32(1))
			}
			return (_r[0].X_mp_d)
		}() = _rl
		_r[0].X_mp_size = _rs
	}
	if _q != nil {
		_qn -= bool2int((*elem0(_qp, uintptr(_qn-int32(1)))) == 0)

		_q[0].X_mp_size = func() int32 {
			if _ns < int32(0) {
				return (-_qn)
			}
			return _qn
		}()
	}
	return _rl

	_ = _3___cy
	panic(0)
}

func _mpn_div_qr_1(tls *crt.TLS, _qp *uint32, _np *uint32, _nn int32, _d uint32) (r0 uint32) {
	var _1_r, _3_shift, _4___ctz_x, _4___ctz_c, _5___clz_x, _5___clz_c uint32
	var _6_inv Tgmp_div_inverse

	if (_d & (_d - uint32(1))) != 0 {
		goto _0
	}
	_1_r = (*_np) & (_d - uint32(1))
	if _qp == nil {
		goto _1
	}
	if _d <= uint32(1) {
		Xmpn_copyi(tls, _qp, _np, _nn)
		goto _3
	}
	_4___ctz_x = _d
	_4___ctz_c = 0
	_5___clz_x = _4___ctz_x & (-_4___ctz_x)
	_5___clz_c = 0
_6:
	if (_5___clz_x & uint32(4278190080)) != 0 {
		goto _9
	}
	_5___clz_x <<= 8
	_5___clz_c += uint32(8)
	goto _6
_9:
	if (_5___clz_x & uint32(2147483648)) != 0 {
		goto _13
	}
	_5___clz_x <<= 1
	_5___clz_c += 1
	goto _9
_13:
	_4___ctz_c = _5___clz_c
	_3_shift = uint32(31) - _4___ctz_c
	Xmpn_rshift(tls, _qp, _np, _nn, _3_shift)
_3:
_1:
	return _1_r

_0:
	_mpn_div_qr_1_invert(tls, &_6_inv, _d)
	return _mpn_div_qr_1_preinv(tls, _qp, _np, _nn, &_6_inv)
}

func Xmpz_roinit_n(tls *crt.TLS, _x *[1]Xmpz_srcptr, _xp *uint32, _xs int32) (r0 *Xmpz_srcptr) {
	_x[0].X_mp_alloc = int32(0)
	_x[0].X_mp_d = _xp
	Xmpz_limbs_finish(tls, _x, _xs)
	return &_x[0]
}

func Xmpz_limbs_finish(tls *crt.TLS, _x *[1]Xmpz_srcptr, _xs int32) {
	var _xn int32
	_xn = _mpn_normalized_size(tls, _x[0].X_mp_d, func() int32 {
		if _xs >= int32(0) {
			return _xs
		}
		return (-_xs)
	}())
	_x[0].X_mp_size = func() int32 {
		if _xs < int32(0) {
			return (-_xn)
		}
		return _xn
	}()
}

func Xmpn_sqrtrem(tls *crt.TLS, _sp *uint32, _rp *uint32, _p *uint32, _n int32) (r0 int32) {
	var _res int32
	var _s, _r, _u [1]Xmpz_srcptr

	Xmpz_init(tls, &_r)
	Xmpz_init(tls, &_s)
	Xmpz_rootrem(tls, &_s, &_r, (*[1]Xmpz_srcptr)(unsafe.Pointer(Xmpz_roinit_n(tls, &_u, _p, _n))), uint32(2))

	Xmpn_copyd(tls, _sp, _s[0].X_mp_d, _s[0].X_mp_size)
	Xmpz_clear(tls, &_s)
	_res = _r[0].X_mp_size
	if _rp != nil {
		Xmpn_copyd(tls, _rp, _r[0].X_mp_d, _res)
	}
	Xmpz_clear(tls, &_r)
	return _res
}

func Xmpn_scan0(tls *crt.TLS, _ptr *uint32, _bit uint32) (r0 uint32) {
	var _i int32
	_i = int32(_bit / uint32(32))
	return _mpn_common_scan(tls, (^(*elem0(_ptr, uintptr(_i))))&(uint32(4294967295)<<uint(int32(_bit%uint32(32)))), _i, _ptr, _i, uint32(4294967295))
}

func _mpn_common_scan(tls *crt.TLS, _limb uint32, _i int32, _up *uint32, _un int32, _ux uint32) (r0 uint32) {
	var _cnt, _2___ctz_x, _2___ctz_c, _3___clz_x, _3___clz_c uint32

_0:
	if _limb != 0 {
		goto _1
	}
	_i += 1
	if _i == _un {
		return func() uint32 {
			if _ux == 0 {
				return uint32(4294967295)
			}
			return (uint32(_un) * uint32(32))
		}()
	}
	_limb = _ux ^ (*elem0(_up, uintptr(_i)))
	goto _0
_1:
	_2___ctz_x = _limb
	_2___ctz_c = 0
	_3___clz_x = _2___ctz_x & (-_2___ctz_x)
	_3___clz_c = 0
_7:
	if (_3___clz_x & uint32(4278190080)) != 0 {
		goto _10
	}
	_3___clz_x <<= 8
	_3___clz_c += uint32(8)
	goto _7
_10:
	if (_3___clz_x & uint32(2147483648)) != 0 {
		goto _14
	}
	_3___clz_x <<= 1
	_3___clz_c += 1
	goto _10
_14:
	_2___ctz_c = _3___clz_c
	_cnt = uint32(31) - _2___ctz_c
	return (uint32(_i) * uint32(32)) + _cnt
}

func Xmpn_scan1(tls *crt.TLS, _ptr *uint32, _bit uint32) (r0 uint32) {
	var _i int32
	_i = int32(_bit / uint32(32))
	return _mpn_common_scan(tls, (*elem0(_ptr, uintptr(_i)))&(uint32(4294967295)<<uint(int32(_bit%uint32(32)))), _i, _ptr, _i, 0)
}

func Xmpn_com(tls *crt.TLS, _rp *uint32, _up *uint32, _n int32) {
_0:
	if preInc1(&_n, -1) >= int32(0) {
		*postInc0(&_rp, 4) = ^(*postInc0(&_up, 4))
		goto _0
	}
}

func Xmpn_neg(tls *crt.TLS, _rp *uint32, _up *uint32, _n int32) (r0 uint32) {
_0:
	if (*_up) != 0 {
		goto _1
	}
	*_rp = 0
	if preInc1(&_n, -1) == 0 {
		return 0
	}
	*(*uintptr)(unsafe.Pointer(&_up)) += uintptr(4)
	*(*uintptr)(unsafe.Pointer(&_rp)) += uintptr(4)
	goto _0
_1:
	*_rp = -(*_up)
	Xmpn_com(tls, preInc0(&_rp, 4), preInc0(&_up, 4), preInc1(&_n, -1))
	return uint32(1)
}

func Xmpn_popcount(tls *crt.TLS, _p *uint32, _n int32) (r0 uint32) {
	var _i int32
	var _c uint32
	*func() *int32 { _c = 0; return &_i }() = int32(0)
_0:
	if _i >= _n {
		goto _3
	}
	_c += _gmp_popcount_limb(tls, *elem0(_p, uintptr(_i)))
	_i += 1
	goto _0
_3:
	return _c
}

func _gmp_popcount_limb(tls *crt.TLS, _x uint32) (r0 uint32) {
	var _c, _1_w uint32
	_c = 0
_0:
	if _x <= 0 {
		goto _3
	}
	_1_w = ((_x >> 1) & uint32(21845)) + (_x & uint32(21845))
	_1_w = ((_1_w >> 2) & uint32(13107)) + (_1_w & uint32(13107))
	_1_w = ((_1_w >> 4) & uint32(3855)) + (_1_w & uint32(3855))
	_1_w = (_1_w >> 8) + (_1_w & uint32(255))
	_c += _1_w
	_x >>= 16
	goto _0
_3:
	return _c
}

func Xmpn_get_str(tls *crt.TLS, _sp *uint8, _base int32, _up *uint32, _un int32) (r0 uint32) {
	var _bits uint32
	var _1_info Tmpn_base_info

	_bits = _mpn_base_power_of_two_p(tls, uint32(_base))
	if _bits != 0 {
		return _mpn_get_str_bits(tls, _sp, _bits, _up, _un)
	}
	_mpn_get_base_info(tls, &_1_info, uint32(_base))
	return _mpn_get_str_other(tls, _sp, _base, &_1_info, _up, _un)
}

// C comment
//  /* MPN base conversion. */
func _mpn_base_power_of_two_p(tls *crt.TLS, _b uint32) (r0 uint32) {
	switch _b {
	case uint32(2):
		goto _1
	case uint32(4):
		goto _2
	case uint32(8):
		goto _3
	case uint32(16):
		goto _4
	case uint32(32):
		goto _5
	case uint32(64):
		goto _6
	case uint32(128):
		goto _7
	case uint32(256):
		goto _8
	default:
		goto _9
	}

_1:
	return uint32(1)

_2:
	return uint32(2)

_3:
	return uint32(3)

_4:
	return uint32(4)

_5:
	return uint32(5)

_6:
	return uint32(6)

_7:
	return uint32(7)

_8:
	return uint32(8)

_9:
	return 0
}

func _mpn_get_str_bits(tls *crt.TLS, _sp *uint8, _bits uint32, _up *uint32, _un int32) (r0 uint32) {
	var _i int32
	var _sn, _j, _shift uint32
	var _mask, _1_digit uint8
	_sn = ((((uint32(_un-int32(1)) * uint32(32)) + _mpn_limb_size_in_base_2(tls, *elem0(_up, uintptr(_un-int32(1))))) + _bits) - uint32(1)) / _bits
	_mask = uint8((uint32(1) << uint(int32(_bits))) - uint32(1))
	*func() *uint32 { *func() *uint32 { _i = int32(0); return &_j }() = _sn; return &_shift }() = 0
_0:
	if postInc2(&_j, uint32(4294967295)) <= 0 {
		goto _3
	}
	_1_digit = uint8((*elem0(_up, uintptr(_i))) >> uint(int32(_shift)))
	_shift += _bits
	if (_shift >= uint32(32)) && (preInc1(&_i, 1) < _un) {
		_shift -= uint32(32)
		{
			p := &_1_digit
			*p = uint8(uint32(*p) | ((*elem0(_up, uintptr(_i))) << uint(int32(_bits-_shift))))
		}
	}
	*elem3(_sp, uintptr(_j)) = uint8(int32(_1_digit) & int32(_mask))
	goto _0
_3:
	return _sn
}

func _mpn_get_base_info(tls *crt.TLS, _info *Tmpn_base_info, _b uint32) {
	var _m, _p, _exp uint32
	_m = uint32(4294967295) / _b
	*func() *uint32 { _exp = uint32(1); return &_p }() = _b
_0:
	if _p > _m {
		goto _3
	}
	_p *= _b
	_exp += 1
	goto _0
_3:
	_info.Xexp = _exp
	_info.Xbb = _p
}

func _mpn_get_str_other(tls *crt.TLS, _sp *uint8, _base int32, _info *Tmpn_base_info, _up *uint32, _un int32) (r0 uint32) {
	var _sn, _i, _2_w, _2_done uint32
	var _3_t uint8
	var _binv, _1_bbinv Tgmp_div_inverse
	_mpn_div_qr_1_invert(tls, &_binv, uint32(_base))
	_sn = 0
	if _un <= int32(1) {
		goto _0
	}
	_mpn_div_qr_1_invert(tls, &_1_bbinv, _info.Xbb)
_1:
	_2_w = _mpn_div_qr_1_preinv(tls, _up, _up, _un, &_1_bbinv)
	_un -= bool2int((*elem0(_up, uintptr(_un-int32(1)))) == 0)
	_2_done = _mpn_limb_get_str(tls, elem3(_sp, uintptr(_sn)), _2_w, &_binv)
	_sn += _2_done
_2:
	if _2_done >= _info.Xexp {
		goto _5
	}
	*elem3(_sp, uintptr(postInc2(&_sn, uint32(1)))) = 0
	_2_done += 1
	goto _2
_5:
	if _un > int32(1) {
		goto _1
	}
_0:
	_sn += _mpn_limb_get_str(tls, elem3(_sp, uintptr(_sn)), *_up, &_binv)
	_i = 0
_6:
	if ((uint32(2) * _i) + uint32(1)) >= _sn {
		goto _9
	}
	_3_t = *elem3(_sp, uintptr(_i))
	*elem3(_sp, uintptr(_i)) = *elem3(_sp, uintptr((_sn-_i)-uint32(1)))
	*elem3(_sp, uintptr((_sn-_i)-uint32(1))) = _3_t
	_i += 1
	goto _6
_9:
	return _sn
}

// C comment
//  /* We generate digits from the least significant end, and reverse at
//     the end. */
func _mpn_limb_get_str(tls *crt.TLS, _sp *uint8, _w uint32, _binv *Tgmp_div_inverse) (r0 uint32) {
	var _i int32
	var _1_h, _1_l, _1_r, _2__qh, _2__ql, _2__r, _2__mask, _3___x0, _3___x1, _3___x2, _3___x3, _3___ul, _3___vl, _3___uh, _3___vh, _3___u, _3___v, _4___x uint32
	_i = int32(0)
_0:
	if _w <= 0 {
		goto _3
	}
	_1_h = _w >> uint(int32(uint32(32)-_binv.Xshift))
	_1_l = _w << uint(int32(_binv.Xshift))
	_3___u = _1_h
	_3___v = _binv.Xdi
	_3___ul = _3___u & uint32(65535)
	_3___uh = _3___u >> 16
	_3___vl = _3___v & uint32(65535)
	_3___vh = _3___v >> 16
	_3___x0 = _3___ul * _3___vl
	_3___x1 = _3___ul * _3___vh
	_3___x2 = _3___uh * _3___vl
	_3___x3 = _3___uh * _3___vh
	_3___x1 += _3___x0 >> 16
	_3___x1 += _3___x2
	if _3___x1 < _3___x2 {
		_3___x3 += uint32(65536)
	}
	_2__qh = _3___x3 + (_3___x1 >> 16)
	_2__ql = (_3___x1 << 16) + (_3___x0 & uint32(65535))
	_4___x = _2__ql + _1_l
	_2__qh = (_2__qh + (_1_h + uint32(1))) + uint32(bool2int(_4___x < _2__ql))
	_2__ql = _4___x
	_2__r = _1_l - (_2__qh * _binv.Xd1)
	_2__mask = -uint32(bool2int(_2__r > _2__ql))
	_2__qh += _2__mask
	_2__r += _2__mask & _binv.Xd1
	if _2__r >= _binv.Xd1 {
		_2__r -= _binv.Xd1
		_2__qh += 1
	}
	_1_r = _2__r
	_w = _2__qh

	_1_r >>= uint(int32(_binv.Xshift))
	*elem3(_sp, uintptr(_i)) = uint8(_1_r)
	_i += 1
	goto _0
_3:
	return uint32(_i)
}

func Xmpn_set_str(tls *crt.TLS, _rp *uint32, _sp *uint8, _sn uint32, _base int32) (r0 int32) {
	var _bits uint32
	var _1_info Tmpn_base_info
	if _sn == 0 {
		return int32(0)
	}
	_bits = _mpn_base_power_of_two_p(tls, uint32(_base))
	if _bits != 0 {
		return _mpn_set_str_bits(tls, _rp, _sp, _sn, _bits)
	}
	_mpn_get_base_info(tls, &_1_info, uint32(_base))
	return _mpn_set_str_other(tls, _rp, _sp, _sn, uint32(_base), &_1_info)
}

func _mpn_set_str_bits(tls *crt.TLS, _rp *uint32, _sp *uint8, _sn uint32, _bits uint32) (r0 int32) {
	var _rn int32
	var _j, _shift uint32
	*func() *uint32 { *func() *int32 { _j = _sn; return &_rn }() = int32(0); return &_shift }() = 0
_0:
	if postInc2(&_j, uint32(4294967295)) <= 0 {
		goto _3
	}
	if _shift == 0 {
		*elem0(_rp, uintptr(postInc1(&_rn, 1))) = uint32(*elem3(_sp, uintptr(_j)))
		_shift += _bits
		goto _5
	}
	*elem0(_rp, uintptr(_rn-int32(1))) |= uint32(*elem3(_sp, uintptr(_j))) << uint(int32(_shift))
	_shift += _bits
	if _shift < uint32(32) {
		goto _6
	}
	_shift -= uint32(32)
	if _shift > 0 {
		*elem0(_rp, uintptr(postInc1(&_rn, 1))) = uint32(*elem3(_sp, uintptr(_j))) >> uint(int32(_bits-_shift))
	}
_6:
_5:
	goto _0
_3:
	_rn = _mpn_normalized_size(tls, _rp, _rn)
	return _rn
}

// C comment
//  /* Result is usually normalized, except for all-zero input, in which
//     case a single zero limb is written at *RP, and 1 is returned. */
func _mpn_set_str_other(tls *crt.TLS, _rp *uint32, _sp *uint8, _sn uint32, _b uint32, _info *Tmpn_base_info) (r0 int32) {
	var _rn int32
	var _w, _k, _j, _1_cy uint32

	_k = uint32(1) + ((_sn - uint32(1)) % _info.Xexp)
	_j = 0
	_w = uint32(*elem3(_sp, uintptr(postInc2(&_j, uint32(1)))))
_0:
	if preInc2(&_k, uint32(4294967295)) != 0 {
		_w = (_w * _b) + uint32(*elem3(_sp, uintptr(postInc2(&_j, uint32(1)))))
		goto _0
	}
	*_rp = _w
	_rn = int32(1)
_2:
	if _j >= _sn {
		goto _5
	}
	_w = uint32(*elem3(_sp, uintptr(postInc2(&_j, uint32(1)))))
	_k = uint32(1)
_6:
	if _k >= _info.Xexp {
		goto _9
	}
	_w = (_w * _b) + uint32(*elem3(_sp, uintptr(postInc2(&_j, uint32(1)))))
	_k += 1
	goto _6
_9:
	_1_cy = Xmpn_mul_1(tls, _rp, _rp, _rn, _info.Xbb)
	_1_cy += Xmpn_add_1(tls, _rp, _rp, _rn, _w)
	if _1_cy > 0 {
		*elem0(_rp, uintptr(postInc1(&_rn, 1))) = _1_cy
	}
	goto _2
_5:
	return _rn
}

// C comment
//  /* MPZ comparisons and the like. */
func Xmpz_sgn(tls *crt.TLS, _u *[1]Xmpz_srcptr) (r0 int32) {
	return bool2int((_u[0].X_mp_size) > int32(0)) - bool2int((_u[0].X_mp_size) < int32(0))
}

func Xmpz_cmp_si(tls *crt.TLS, _u *[1]Xmpz_srcptr, _v int32) (r0 int32) {
	var _usize int32
	_usize = _u[0].X_mp_size
	if _usize < int32(-1) {
		return int32(-1)
	}
	if _v >= int32(0) {
		return Xmpz_cmp_ui(tls, _u, uint32(_v))
	}
	if _usize >= int32(0) {
		return int32(1)
	}
	return bool2int((-(uint32(_v+int32(1)) - uint32(1))) > (*(_u[0].X_mp_d))) - bool2int((-(uint32(_v+int32(1)) - uint32(1))) < (*(_u[0].X_mp_d)))
}

func Xmpz_cmp_ui(tls *crt.TLS, _u *[1]Xmpz_srcptr, _v uint32) (r0 int32) {
	var _usize int32
	_usize = _u[0].X_mp_size
	if _usize > int32(1) {
		return int32(1)
	}
	if _usize < int32(0) {
		return int32(-1)
	}
	return bool2int(Xmpz_get_ui(tls, _u) > _v) - bool2int(Xmpz_get_ui(tls, _u) < _v)
}

func Xmpz_cmp(tls *crt.TLS, _a *[1]Xmpz_srcptr, _b *[1]Xmpz_srcptr) (r0 int32) {
	var _asize, _bsize int32
	_asize = _a[0].X_mp_size
	_bsize = _b[0].X_mp_size
	if _asize != _bsize {
		return func() int32 {
			if _asize < _bsize {
				return int32(-1)
			}
			return int32(1)
		}()
	}
	if _asize >= int32(0) {
		return Xmpn_cmp(tls, _a[0].X_mp_d, _b[0].X_mp_d, _asize)
	}
	return Xmpn_cmp(tls, _b[0].X_mp_d, _a[0].X_mp_d, -_asize)
}

func Xmpz_cmp_d(tls *crt.TLS, _x *[1]Xmpz_srcptr, _d float64) (r0 int32) {
	if (_x[0].X_mp_size) >= int32(0) {
		goto _0
	}
	if _d >= float64(0) {
		return int32(-1)
	}
	return -Xmpz_cmpabs_d(tls, _x, _d)

_0:
	if _d < float64(0) {
		return int32(1)
	}
	return Xmpz_cmpabs_d(tls, _x, _d)
}

func Xmpz_cmpabs_d(tls *crt.TLS, _x *[1]Xmpz_srcptr, _d float64) (r0 int32) {
	var _xn, _i int32
	var _2_f, _2_xl uint32
	var _B, _Bi float64
	_xn = _x[0].X_mp_size
	_d = func() float64 {
		if _d >= 0 {
			return _d
		}
		return (-_d)
	}()
	if _xn == int32(0) {
		goto _2
	}
	_xn = func() int32 {
		if _xn >= int32(0) {
			return _xn
		}
		return (-_xn)
	}()
	_B = 4.294967296e+09
	_Bi = float64(1) / _B
	_i = int32(1)
_5:
	if _i >= _xn {
		goto _8
	}
	_d *= _Bi
	_i += 1
	goto _5
_8:
	if _d >= _B {
		return int32(-1)
	}
	_i = _xn
_10:
	if postInc1(&_i, -1) <= int32(0) {
		goto _13
	}
	_2_f = uint32(_d)
	_2_xl = *elem0(_x[0].X_mp_d, uintptr(_i))
	if _2_xl > _2_f {
		return int32(1)
	}
	if _2_xl < _2_f {
		return int32(-1)
	}
	_d = _B * (_d - float64(_2_f))
	goto _10
_13:
_2:
	return -bool2int(_d > float64(0))
}

func Xmpz_abs(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr) {
	Xmpz_set(tls, _r, _u)
	_r[0].X_mp_size = func() int32 {
		if (_r[0].X_mp_size) >= int32(0) {
			return (_r[0].X_mp_size)
		}
		return (-(_r[0].X_mp_size))
	}()
}

func Xmpz_ui_sub(tls *crt.TLS, _r *[1]Xmpz_srcptr, _a uint32, _b *[1]Xmpz_srcptr) {
	if (_b[0].X_mp_size) < int32(0) {
		_r[0].X_mp_size = _mpz_abs_add_ui(tls, _r, _b, _a)
		goto _1
	}
	_r[0].X_mp_size = -_mpz_abs_sub_ui(tls, _r, _b, _a)
_1:
}

// C comment
//  /* MPZ multiplication */
func Xmpz_mul_si(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v int32) {
	if _v < int32(0) {
		Xmpz_mul_ui(tls, _r, _u, -(uint32(_v+int32(1)) - uint32(1)))
		Xmpz_neg(tls, _r, _r)
		goto _1
	}
	Xmpz_mul_ui(tls, _r, _u, uint32(_v))
_1:
}

func Xmpz_mul_2exp(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _bits uint32) {
	var _un, _rn, _limbs int32
	var _shift, _2_cy uint32
	var _rp *uint32
	_un = func() int32 {
		if (_u[0].X_mp_size) >= int32(0) {
			return (_u[0].X_mp_size)
		}
		return (-(_u[0].X_mp_size))
	}()
	if _un == int32(0) {
		_r[0].X_mp_size = int32(0)
		return
	}
	_limbs = int32(_bits / uint32(32))
	_shift = _bits % uint32(32)
	_rn = (_un + _limbs) + bool2int(_shift > 0)
	_rp = func() *uint32 {
		if _rn > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _rn)
		}
		return (_r[0].X_mp_d)
	}()
	if _shift > 0 {
		_2_cy = Xmpn_lshift(tls, elem0(_rp, uintptr(_limbs)), _u[0].X_mp_d, _un, _shift)
		*elem0(_rp, uintptr(_rn-int32(1))) = _2_cy
		_rn -= bool2int(_2_cy == 0)
		goto _6
	}
	Xmpn_copyd(tls, elem0(_rp, uintptr(_limbs)), _u[0].X_mp_d, _un)
_6:
	Xmpn_zero(tls, _rp, _limbs)
	_r[0].X_mp_size = func() int32 {
		if (_u[0].X_mp_size) < int32(0) {
			return (-_rn)
		}
		return _rn
	}()
}

func Xmpz_addmul_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v uint32) {
	var _t [1]Xmpz_srcptr
	Xmpz_init(tls, &_t)
	Xmpz_mul_ui(tls, &_t, _u, _v)
	Xmpz_add(tls, _r, _r, &_t)
	Xmpz_clear(tls, &_t)
}

func Xmpz_addmul(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v *[1]Xmpz_srcptr) {
	var _t [1]Xmpz_srcptr
	Xmpz_init(tls, &_t)
	Xmpz_mul(tls, &_t, _u, _v)
	Xmpz_add(tls, _r, _r, &_t)
	Xmpz_clear(tls, &_t)
}

func Xmpz_submul_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v uint32) {
	var _t [1]Xmpz_srcptr
	Xmpz_init(tls, &_t)
	Xmpz_mul_ui(tls, &_t, _u, _v)
	Xmpz_sub(tls, _r, _r, &_t)
	Xmpz_clear(tls, &_t)
}

func Xmpz_submul(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v *[1]Xmpz_srcptr) {
	var _t [1]Xmpz_srcptr
	Xmpz_init(tls, &_t)
	Xmpz_mul(tls, &_t, _u, _v)
	Xmpz_sub(tls, _r, _r, &_t)
	Xmpz_clear(tls, &_t)
}

func Xmpz_cdiv_qr(tls *crt.TLS, _q *[1]Xmpz_srcptr, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d *[1]Xmpz_srcptr) {
	_mpz_div_qr(tls, _q, _r, _n, _d, int32(1))
}

func Xmpz_fdiv_qr(tls *crt.TLS, _q *[1]Xmpz_srcptr, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d *[1]Xmpz_srcptr) {
	_mpz_div_qr(tls, _q, _r, _n, _d, int32(0))
}

func Xmpz_tdiv_qr(tls *crt.TLS, _q *[1]Xmpz_srcptr, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d *[1]Xmpz_srcptr) {
	_mpz_div_qr(tls, _q, _r, _n, _d, int32(2))
}

func Xmpz_cdiv_q(tls *crt.TLS, _q *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d *[1]Xmpz_srcptr) {
	_mpz_div_qr(tls, _q, nil, _n, _d, int32(1))
}

func Xmpz_fdiv_q(tls *crt.TLS, _q *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d *[1]Xmpz_srcptr) {
	_mpz_div_qr(tls, _q, nil, _n, _d, int32(0))
}

func Xmpz_cdiv_r(tls *crt.TLS, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d *[1]Xmpz_srcptr) {
	_mpz_div_qr(tls, nil, _r, _n, _d, int32(1))
}

func Xmpz_fdiv_r(tls *crt.TLS, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d *[1]Xmpz_srcptr) {
	_mpz_div_qr(tls, nil, _r, _n, _d, int32(0))
}

func Xmpz_tdiv_r(tls *crt.TLS, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d *[1]Xmpz_srcptr) {
	_mpz_div_qr(tls, nil, _r, _n, _d, int32(2))
}

func Xmpz_cdiv_q_2exp(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _cnt uint32) {
	_mpz_div_q_2exp(tls, _r, _u, _cnt, int32(1))
}

func Xmpz_fdiv_q_2exp(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _cnt uint32) {
	_mpz_div_q_2exp(tls, _r, _u, _cnt, int32(0))
}

func Xmpz_cdiv_r_2exp(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _cnt uint32) {
	_mpz_div_r_2exp(tls, _r, _u, _cnt, int32(1))
}

func _mpz_div_r_2exp(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _bit_index uint32, _mode int32) {
	var _us, _un, _rn, _3_i int32
	var _mask, _4___cy uint32
	var _rp *uint32
	_us = _u[0].X_mp_size
	if (_us == int32(0)) || (_bit_index == 0) {
		_r[0].X_mp_size = int32(0)
		return
	}
	_rn = int32(((_bit_index + uint32(32)) - uint32(1)) / uint32(32))

	_rp = func() *uint32 {
		if _rn > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _rn)
		}
		return (_r[0].X_mp_d)
	}()
	_un = func() int32 {
		if _us >= int32(0) {
			return _us
		}
		return (-_us)
	}()
	_mask = uint32(4294967295) >> uint(int32((uint32(_rn)*uint32(32))-_bit_index))
	if _rn <= _un {
		goto _6
	}
	if _mode != func() int32 {
		if _us > int32(0) {
			return int32(1)
		}
		return int32(0)
	}() {
		goto _9
	}
	_4___cy = uint32(bool2int(Xmpn_neg(tls, _rp, _u[0].X_mp_d, _un) == 0))

	_3_i = _un
_11:
	if _3_i >= (_rn - int32(1)) {
		goto _14
	}
	*elem0(_rp, uintptr(_3_i)) = uint32(4294967295)
	_3_i += 1
	goto _11
_14:
	*elem0(_rp, uintptr(_rn-int32(1))) = _mask
	_us = -_us
	goto _15
_9:
	if &_r[0] != &_u[0] {
		Xmpn_copyi(tls, _rp, _u[0].X_mp_d, _un)
	}
	_rn = _un
_15:
	goto _17
_6:
	if &_r[0] != &_u[0] {
		Xmpn_copyi(tls, _rp, _u[0].X_mp_d, _rn-int32(1))
	}
	*elem0(_rp, uintptr(_rn-int32(1))) = (*elem0(_u[0].X_mp_d, uintptr(_rn-int32(1)))) & _mask
	if _mode == func() int32 {
		if _us > int32(0) {
			return int32(1)
		}
		return int32(0)
	}() {
		Xmpn_neg(tls, _rp, _rp, _rn)
		*elem0(_rp, uintptr(_rn-int32(1))) &= _mask
		_us = -_us
	}
_17:
	_rn = _mpn_normalized_size(tls, _rp, _rn)
	_r[0].X_mp_size = func() int32 {
		if _us < int32(0) {
			return (-_rn)
		}
		return _rn
	}()
	_ = _4___cy
}

func Xmpz_fdiv_r_2exp(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _cnt uint32) {
	_mpz_div_r_2exp(tls, _r, _u, _cnt, int32(0))
}

func Xmpz_tdiv_r_2exp(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _cnt uint32) {
	_mpz_div_r_2exp(tls, _r, _u, _cnt, int32(2))
}

func Xmpz_mod(tls *crt.TLS, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d *[1]Xmpz_srcptr) {
	_mpz_div_qr(tls, nil, _r, _n, _d, func() int32 {
		if (_d[0].X_mp_size) >= int32(0) {
			return int32(0)
		}
		return int32(1)
	}())
}

func Xmpz_divexact(tls *crt.TLS, _q *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d *[1]Xmpz_srcptr) {
	var _1___cy uint32
	_1___cy = uint32(_mpz_div_qr(tls, _q, nil, _n, _d, int32(2)))

	_ = _1___cy
}

func Xmpz_divisible_p(tls *crt.TLS, _n *[1]Xmpz_srcptr, _d *[1]Xmpz_srcptr) (r0 int32) {
	return bool2int(_mpz_div_qr(tls, nil, nil, _n, _d, int32(2)) == int32(0))
}

func Xmpz_congruent_p(tls *crt.TLS, _a *[1]Xmpz_srcptr, _b *[1]Xmpz_srcptr, _m *[1]Xmpz_srcptr) (r0 int32) {
	var _res int32
	var _t [1]Xmpz_srcptr
	if Xmpz_sgn(tls, _m) == int32(0) {
		return bool2int(Xmpz_cmp(tls, _a, _b) == int32(0))
	}
	Xmpz_init(tls, &_t)
	Xmpz_sub(tls, &_t, _a, _b)
	_res = Xmpz_divisible_p(tls, &_t, _m)
	Xmpz_clear(tls, &_t)
	return _res
}

func Xmpz_cdiv_qr_ui(tls *crt.TLS, _q *[1]Xmpz_srcptr, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d uint32) (r0 uint32) {
	return _mpz_div_qr_ui(tls, _q, _r, _n, _d, int32(1))
}

func Xmpz_fdiv_qr_ui(tls *crt.TLS, _q *[1]Xmpz_srcptr, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d uint32) (r0 uint32) {
	return _mpz_div_qr_ui(tls, _q, _r, _n, _d, int32(0))
}

func Xmpz_tdiv_qr_ui(tls *crt.TLS, _q *[1]Xmpz_srcptr, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d uint32) (r0 uint32) {
	return _mpz_div_qr_ui(tls, _q, _r, _n, _d, int32(2))
}

func Xmpz_cdiv_q_ui(tls *crt.TLS, _q *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d uint32) (r0 uint32) {
	return _mpz_div_qr_ui(tls, _q, nil, _n, _d, int32(1))
}

func Xmpz_fdiv_q_ui(tls *crt.TLS, _q *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d uint32) (r0 uint32) {
	return _mpz_div_qr_ui(tls, _q, nil, _n, _d, int32(0))
}

func Xmpz_cdiv_r_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d uint32) (r0 uint32) {
	return _mpz_div_qr_ui(tls, nil, _r, _n, _d, int32(1))
}

func Xmpz_fdiv_r_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d uint32) (r0 uint32) {
	return _mpz_div_qr_ui(tls, nil, _r, _n, _d, int32(0))
}

func Xmpz_tdiv_r_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d uint32) (r0 uint32) {
	return _mpz_div_qr_ui(tls, nil, _r, _n, _d, int32(2))
}

func Xmpz_cdiv_ui(tls *crt.TLS, _n *[1]Xmpz_srcptr, _d uint32) (r0 uint32) {
	return _mpz_div_qr_ui(tls, nil, nil, _n, _d, int32(1))
}

func Xmpz_fdiv_ui(tls *crt.TLS, _n *[1]Xmpz_srcptr, _d uint32) (r0 uint32) {
	return _mpz_div_qr_ui(tls, nil, nil, _n, _d, int32(0))
}

func Xmpz_tdiv_ui(tls *crt.TLS, _n *[1]Xmpz_srcptr, _d uint32) (r0 uint32) {
	return _mpz_div_qr_ui(tls, nil, nil, _n, _d, int32(2))
}

func Xmpz_mod_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d uint32) (r0 uint32) {
	return _mpz_div_qr_ui(tls, nil, _r, _n, _d, int32(0))
}

func Xmpz_divexact_ui(tls *crt.TLS, _q *[1]Xmpz_srcptr, _n *[1]Xmpz_srcptr, _d uint32) {
	var _1___cy uint32
	_1___cy = _mpz_div_qr_ui(tls, _q, nil, _n, _d, int32(2))

	_ = _1___cy
}

func Xmpz_divisible_ui_p(tls *crt.TLS, _n *[1]Xmpz_srcptr, _d uint32) (r0 int32) {
	return bool2int(_mpz_div_qr_ui(tls, nil, nil, _n, _d, int32(2)) == 0)
}

func Xmpz_gcd_ui(tls *crt.TLS, _g *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v uint32) (r0 uint32) {
	var _un int32
	if _v != 0 {
		goto _0
	}
	if _g != nil {
		Xmpz_abs(tls, _g, _u)
	}
	goto _2
_0:
	_un = func() int32 {
		if (_u[0].X_mp_size) >= int32(0) {
			return (_u[0].X_mp_size)
		}
		return (-(_u[0].X_mp_size))
	}()
	if _un != int32(0) {
		_v = _mpn_gcd_11(tls, _mpn_div_qr_1(tls, nil, _u[0].X_mp_d, _un, _v), _v)
	}
	if _g != nil {
		Xmpz_set_ui(tls, _g, _v)
	}
_2:
	return _v
}

// C comment
//  /* GCD */
func _mpn_gcd_11(tls *crt.TLS, _u uint32, _v uint32) (r0 uint32) {
	var _shift, _1___ctz_x, _1___ctz_c, _2___clz_x, _2___clz_c, _3___mp_limb_t_swap__tmp uint32

	if _u == 0 {
		return _v
	}
	if _v == 0 {
		return _u
	}
	_1___ctz_x = _u | _v
	_1___ctz_c = 0
	_2___clz_x = _1___ctz_x & (-_1___ctz_x)
	_2___clz_c = 0
_5:
	if (_2___clz_x & uint32(4278190080)) != 0 {
		goto _8
	}
	_2___clz_x <<= 8
	_2___clz_c += uint32(8)
	goto _5
_8:
	if (_2___clz_x & uint32(2147483648)) != 0 {
		goto _12
	}
	_2___clz_x <<= 1
	_2___clz_c += 1
	goto _8
_12:
	_1___ctz_c = _2___clz_c
	_shift = uint32(31) - _1___ctz_c
	_u >>= uint(int32(_shift))
	_v >>= uint(int32(_shift))
	if (_u & uint32(1)) != 0 {
		goto _13
	}
	_3___mp_limb_t_swap__tmp = _u
	_u = _v
	_v = _3___mp_limb_t_swap__tmp
_13:
	if (_v & uint32(1)) == 0 {
		_v >>= 1
		goto _13
	}
_16:
	if _u == _v {
		goto _18
	}
	if _u <= _v {
		goto _19
	}
	_u -= _v
_20:
	_u >>= 1
	if (_u & uint32(1)) == 0 {
		goto _20
	}
	goto _21
_19:
	_v -= _u
_22:
	_v >>= 1
	if (_v & uint32(1)) == 0 {
		goto _22
	}
_21:
	goto _16
_18:
	return _u << uint(int32(_shift))
}

func Xmpz_gcd(tls *crt.TLS, _g *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v *[1]Xmpz_srcptr) {
	var _4_c int32
	var _uz, _vz, _gz, _6_vl, _6_ul uint32
	var _tu, _tv [1]Xmpz_srcptr
	if (_u[0].X_mp_size) == int32(0) {
		Xmpz_abs(tls, _g, _v)
		return
	}
	if (_v[0].X_mp_size) == int32(0) {
		Xmpz_abs(tls, _g, _u)
		return
	}
	Xmpz_init(tls, &_tu)
	Xmpz_init(tls, &_tv)
	Xmpz_abs(tls, &_tu, _u)
	_uz = _mpz_make_odd(tls, &_tu)
	Xmpz_abs(tls, &_tv, _v)
	_vz = _mpz_make_odd(tls, &_tv)
	_gz = func() uint32 {
		if _uz < _vz {
			return _uz
		}
		return _vz
	}()
	if (_tu[0].X_mp_size) < (_tv[0].X_mp_size) {
		Xmpz_swap(tls, &_tu, &_tv)
	}
	Xmpz_tdiv_r(tls, &_tu, &_tu, &_tv)
	if (_tu[0].X_mp_size) == int32(0) {
		Xmpz_swap(tls, _g, &_tv)
		goto _9
	}
_5:
	_mpz_make_odd(tls, &_tu)
	_4_c = Xmpz_cmp(tls, &_tu, &_tv)
	if _4_c == int32(0) {
		Xmpz_swap(tls, _g, &_tu)
		goto _9
	}
	if _4_c < int32(0) {
		Xmpz_swap(tls, &_tu, &_tv)
	}
	if (_tv[0].X_mp_size) == int32(1) {
		_6_vl = *(_tv[0].X_mp_d)
		_6_ul = Xmpz_tdiv_ui(tls, &_tu, _6_vl)
		Xmpz_set_ui(tls, _g, _mpn_gcd_11(tls, _6_ul, _6_vl))
		goto _9
	}
	Xmpz_sub(tls, &_tu, &_tu, &_tv)
	goto _5
_9:
	Xmpz_clear(tls, &_tu)
	Xmpz_clear(tls, &_tv)
	Xmpz_mul_2exp(tls, _g, _g, _gz)
}

func _mpz_make_odd(tls *crt.TLS, _r *[1]Xmpz_srcptr) (r0 uint32) {
	var _shift uint32

	_shift = _mpn_common_scan(tls, *(_r[0].X_mp_d), int32(0), _r[0].X_mp_d, int32(0), 0)
	Xmpz_tdiv_q_2exp(tls, _r, _r, _shift)
	return _shift
}

func Xmpz_gcdext(tls *crt.TLS, _g *[1]Xmpz_srcptr, _s *[1]Xmpz_srcptr, _t *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v *[1]Xmpz_srcptr) {
	var _1_sign, _2_sign, _8_c int32
	var _uz, _vz, _gz, _power, _6___mp_bitcnt_t_swap__tmp, _7_shift uint32
	var _tu, _tv, _s0, _s1, _t0, _t1 [1]Xmpz_srcptr
	var _4___mpz_srcptr_swap__tmp, _5___mpz_ptr_swap__tmp *Xmpz_srcptr
	if (_u[0].X_mp_size) != int32(0) {
		goto _0
	}
	_1_sign = Xmpz_sgn(tls, _v)
	Xmpz_abs(tls, _g, _v)
	if _s != nil {
		Xmpz_set_ui(tls, _s, 0)
	}
	if _t != nil {
		Xmpz_set_si(tls, _t, _1_sign)
	}
	return
_0:
	if (_v[0].X_mp_size) != int32(0) {
		goto _3
	}
	_2_sign = Xmpz_sgn(tls, _u)
	Xmpz_abs(tls, _g, _u)
	if _s != nil {
		Xmpz_set_si(tls, _s, _2_sign)
	}
	if _t != nil {
		Xmpz_set_ui(tls, _t, 0)
	}
	return
_3:
	Xmpz_init(tls, &_tu)
	Xmpz_init(tls, &_tv)
	Xmpz_init(tls, &_s0)
	Xmpz_init(tls, &_s1)
	Xmpz_init(tls, &_t0)
	Xmpz_init(tls, &_t1)
	Xmpz_abs(tls, &_tu, _u)
	_uz = _mpz_make_odd(tls, &_tu)
	Xmpz_abs(tls, &_tv, _v)
	_vz = _mpz_make_odd(tls, &_tv)
	_gz = func() uint32 {
		if _uz < _vz {
			return _uz
		}
		return _vz
	}()
	_uz -= _gz
	_vz -= _gz
	if (_tu[0].X_mp_size) >= (_tv[0].X_mp_size) {
		goto _8
	}
	Xmpz_swap(tls, &_tu, &_tv)
	_4___mpz_srcptr_swap__tmp = &_u[0]
	_u = _v
	_v = (*[1]Xmpz_srcptr)(unsafe.Pointer(_4___mpz_srcptr_swap__tmp))
	_5___mpz_ptr_swap__tmp = &_s[0]
	_s = _t
	_t = (*[1]Xmpz_srcptr)(unsafe.Pointer(_5___mpz_ptr_swap__tmp))
	_6___mp_bitcnt_t_swap__tmp = _uz
	_uz = _vz
	_vz = _6___mp_bitcnt_t_swap__tmp
_8:
	Xmpz_setbit(tls, &_t0, _uz)
	Xmpz_tdiv_qr(tls, &_t1, &_tu, &_tu, &_tv)
	Xmpz_mul_2exp(tls, &_t1, &_t1, _uz)
	Xmpz_setbit(tls, &_s1, _vz)
	_power = _uz + _vz
	if (_tu[0].X_mp_size) <= int32(0) {
		goto _12
	}
	_7_shift = _mpz_make_odd(tls, &_tu)
	Xmpz_mul_2exp(tls, &_t0, &_t0, _7_shift)
	Xmpz_mul_2exp(tls, &_s0, &_s0, _7_shift)
	_power += _7_shift
_13:
	_8_c = Xmpz_cmp(tls, &_tu, &_tv)
	if _8_c == int32(0) {
		goto _15
	}
	if _8_c < int32(0) {
		Xmpz_sub(tls, &_tv, &_tv, &_tu)
		Xmpz_add(tls, &_t0, &_t0, &_t1)
		Xmpz_add(tls, &_s0, &_s0, &_s1)
		_7_shift = _mpz_make_odd(tls, &_tv)
		Xmpz_mul_2exp(tls, &_t1, &_t1, _7_shift)
		Xmpz_mul_2exp(tls, &_s1, &_s1, _7_shift)
		goto _18
	}
	Xmpz_sub(tls, &_tu, &_tu, &_tv)
	Xmpz_add(tls, &_t1, &_t0, &_t1)
	Xmpz_add(tls, &_s1, &_s0, &_s1)
	_7_shift = _mpz_make_odd(tls, &_tu)
	Xmpz_mul_2exp(tls, &_t0, &_t0, _7_shift)
	Xmpz_mul_2exp(tls, &_s0, &_s0, _7_shift)
_18:
	_power += _7_shift
	goto _13
_15:
_12:
	Xmpz_mul_2exp(tls, &_tv, &_tv, _gz)
	Xmpz_neg(tls, &_s0, &_s0)
	Xmpz_divexact(tls, &_s1, _v, &_tv)
	Xmpz_abs(tls, &_s1, &_s1)
	Xmpz_divexact(tls, &_t1, _u, &_tv)
	Xmpz_abs(tls, &_t1, &_t1)
_19:
	if postInc2(&_power, uint32(4294967295)) <= 0 {
		goto _20
	}
	if (bool2int((_s0[0].X_mp_size) != int32(0))&int32(*(_s0[0].X_mp_d))) != 0 || (bool2int((_t0[0].X_mp_size) != int32(0))&int32(*(_t0[0].X_mp_d))) != 0 {
		Xmpz_sub(tls, &_s0, &_s0, &_s1)
		Xmpz_add(tls, &_t0, &_t0, &_t1)
	}
	Xmpz_divexact_ui(tls, &_s0, &_s0, uint32(2))
	Xmpz_divexact_ui(tls, &_t0, &_t0, uint32(2))
	goto _19
_20:
	Xmpz_add(tls, &_s1, &_s0, &_s1)
	if Xmpz_cmpabs(tls, &_s0, &_s1) > int32(0) {
		Xmpz_swap(tls, &_s0, &_s1)
		Xmpz_sub(tls, &_t0, &_t0, &_t1)
	}
	if (_u[0].X_mp_size) < int32(0) {
		Xmpz_neg(tls, &_s0, &_s0)
	}
	if (_v[0].X_mp_size) < int32(0) {
		Xmpz_neg(tls, &_t0, &_t0)
	}
	Xmpz_swap(tls, _g, &_tv)
	if _s != nil {
		Xmpz_swap(tls, _s, &_s0)
	}
	if _t != nil {
		Xmpz_swap(tls, _t, &_t0)
	}
	Xmpz_clear(tls, &_tu)
	Xmpz_clear(tls, &_tv)
	Xmpz_clear(tls, &_s0)
	Xmpz_clear(tls, &_s1)
	Xmpz_clear(tls, &_t0)
	Xmpz_clear(tls, &_t1)
	_ = _power
}

func Xmpz_lcm_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v uint32) {
	if (_v == 0) || ((_u[0].X_mp_size) == int32(0)) {
		_r[0].X_mp_size = int32(0)
		return
	}
	_v /= Xmpz_gcd_ui(tls, nil, _u, _v)
	Xmpz_mul_ui(tls, _r, _u, _v)
	Xmpz_abs(tls, _r, _r)
}

func Xmpz_lcm(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v *[1]Xmpz_srcptr) {
	var _g [1]Xmpz_srcptr
	if ((_u[0].X_mp_size) == int32(0)) || ((_v[0].X_mp_size) == int32(0)) {
		_r[0].X_mp_size = int32(0)
		return
	}
	Xmpz_init(tls, &_g)
	Xmpz_gcd(tls, &_g, _u, _v)
	Xmpz_divexact(tls, &_g, _u, &_g)
	Xmpz_mul(tls, _r, &_g, _v)
	Xmpz_clear(tls, &_g)
	Xmpz_abs(tls, _r, _r)
}

func Xmpz_invert(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _m *[1]Xmpz_srcptr) (r0 int32) {
	var _invertible int32
	var _g, _tr [1]Xmpz_srcptr
	if ((_u[0].X_mp_size) == int32(0)) || (Xmpz_cmpabs_ui(tls, _m, uint32(1)) <= int32(0)) {
		return int32(0)
	}
	Xmpz_init(tls, &_g)
	Xmpz_init(tls, &_tr)
	Xmpz_gcdext(tls, &_g, &_tr, nil, _u, _m)
	_invertible = bool2int(Xmpz_cmp_ui(tls, &_g, uint32(1)) == int32(0))
	if _invertible == 0 {
		goto _2
	}
	if (_tr[0].X_mp_size) >= int32(0) {
		goto _3
	}
	if (_m[0].X_mp_size) >= int32(0) {
		Xmpz_add(tls, &_tr, &_tr, _m)
		goto _5
	}
	Xmpz_sub(tls, &_tr, &_tr, _m)
_5:
_3:
	Xmpz_swap(tls, _r, &_tr)
_2:
	Xmpz_clear(tls, &_g)
	Xmpz_clear(tls, &_tr)
	return _invertible
}

// C comment
//  /* Compute s = floor(sqrt(u)) and r = u - s^2. Allows r == NULL */
func Xmpz_sqrtrem(tls *crt.TLS, _s *[1]Xmpz_srcptr, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr) {
	Xmpz_rootrem(tls, _s, _r, _u, uint32(2))
}

func Xmpz_sqrt(tls *crt.TLS, _s *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr) {
	Xmpz_rootrem(tls, _s, nil, _u, uint32(2))
}

func Xmpz_perfect_square_p(tls *crt.TLS, _u *[1]Xmpz_srcptr) (r0 int32) {
	if (_u[0].X_mp_size) <= int32(0) {
		return bool2int((_u[0].X_mp_size) == int32(0))
	}
	return Xmpz_root(tls, nil, _u, uint32(2))
}

func Xmpz_ui_pow_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _blimb uint32, _e uint32) {
	var _b [1]Xmpz_srcptr
	Xmpz_pow_ui(tls, _r, (*[1]Xmpz_srcptr)(unsafe.Pointer(Xmpz_roinit_n(tls, &_b, &_blimb, int32(1)))), _e)
}

func Xmpz_powm(tls *crt.TLS, _r *[1]Xmpz_srcptr, _b *[1]Xmpz_srcptr, _e *[1]Xmpz_srcptr, _m *[1]Xmpz_srcptr) {
	var _en, _mn, _5_bn int32
	var _shift, _3___cy, _8___cy, _9_w, _9_bit uint32
	var _mp, _tp, _7_bp *uint32
	var _minv Tgmp_div_inverse
	var _tr, _base [1]Xmpz_srcptr
	_tp = nil
	_en = func() int32 {
		if (_e[0].X_mp_size) >= int32(0) {
			return (_e[0].X_mp_size)
		}
		return (-(_e[0].X_mp_size))
	}()
	_mn = func() int32 {
		if (_m[0].X_mp_size) >= int32(0) {
			return (_m[0].X_mp_size)
		}
		return (-(_m[0].X_mp_size))
	}()
	if _mn == int32(0) {
		_gmp_die(tls, str(198))
	}
	if _en == int32(0) {
		Xmpz_set_ui(tls, _r, uint32(1))
		return
	}
	_mp = _m[0].X_mp_d
	_mpn_div_qr_invert(tls, &_minv, _mp, _mn)
	_shift = _minv.Xshift
	if _shift <= 0 {
		goto _6
	}
	_minv.Xshift = 0
	_tp = _gmp_xalloc_limbs(tls, _mn)
	_3___cy = Xmpn_lshift(tls, _tp, _mp, _mn, _shift)

	_mp = _tp
_6:
	Xmpz_init(tls, &_base)
	if (_e[0].X_mp_size) >= int32(0) {
		goto _8
	}
	if Xmpz_invert(tls, &_base, _b, _m) == 0 {
		_gmp_die(tls, str(221))
	}
	goto _10
_8:
	Xmpz_abs(tls, &_base, _b)
	_5_bn = _base[0].X_mp_size
	if _5_bn >= _mn {
		_mpn_div_qr_preinv(tls, nil, _base[0].X_mp_d, _base[0].X_mp_size, _mp, _mn, &_minv)
		_5_bn = _mn
	}
	if (_b[0].X_mp_size) >= int32(0) {
		goto _12
	}
	_7_bp = func() *uint32 {
		if _mn > (_base[0].X_mp_alloc) {
			return _mpz_realloc(tls, &_base, _mn)
		}
		return (_base[0].X_mp_d)
	}()
	_8___cy = Xmpn_sub(tls, _7_bp, _mp, _mn, _7_bp, _5_bn)

	_5_bn = _mn
_12:
	_base[0].X_mp_size = _mpn_normalized_size(tls, _base[0].X_mp_d, _5_bn)
_10:
	Xmpz_init_set_ui(tls, &_tr, uint32(1))
_16:
	if preInc1(&_en, -1) < int32(0) {
		goto _17
	}
	_9_w = *elem0(_e[0].X_mp_d, uintptr(_en))
	_9_bit = uint32(2147483648)
_18:
	Xmpz_mul(tls, &_tr, &_tr, &_tr)
	if (_9_w & _9_bit) != 0 {
		Xmpz_mul(tls, &_tr, &_tr, &_base)
	}
	if (_tr[0].X_mp_size) > _mn {
		_mpn_div_qr_preinv(tls, nil, _tr[0].X_mp_d, _tr[0].X_mp_size, _mp, _mn, &_minv)
		_tr[0].X_mp_size = _mpn_normalized_size(tls, _tr[0].X_mp_d, _mn)
	}
	_9_bit >>= 1
	if _9_bit > 0 {
		goto _18
	}
	goto _16
_17:
	if (_tr[0].X_mp_size) >= _mn {
		_minv.Xshift = _shift
		_mpn_div_qr_preinv(tls, nil, _tr[0].X_mp_d, _tr[0].X_mp_size, _mp, _mn, &_minv)
		_tr[0].X_mp_size = _mpn_normalized_size(tls, _tr[0].X_mp_d, _mn)
	}
	if _tp != nil {
		_gmp_free_func(tls, unsafe.Pointer(_tp), 0)
	}
	Xmpz_swap(tls, _r, &_tr)
	Xmpz_clear(tls, &_tr)
	Xmpz_clear(tls, &_base)
	_ = _3___cy
	_ = _8___cy
}

func Xmpz_powm_ui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _b *[1]Xmpz_srcptr, _elimb uint32, _m *[1]Xmpz_srcptr) {
	var _e [1]Xmpz_srcptr
	Xmpz_powm(tls, _r, _b, (*[1]Xmpz_srcptr)(unsafe.Pointer(Xmpz_roinit_n(tls, &_e, &_elimb, int32(1)))), _m)
}

func Xmpz_fac_ui(tls *crt.TLS, _x *[1]Xmpz_srcptr, _n uint32) {
	Xmpz_set_ui(tls, _x, _n+uint32(bool2int(_n == 0)))
_0:
	if _n > uint32(2) {
		Xmpz_mul_ui(tls, _x, _x, preInc2(&_n, uint32(4294967295)))
		goto _0
	}
}

func Xmpz_bin_uiui(tls *crt.TLS, _r *[1]Xmpz_srcptr, _n uint32, _k uint32) {
	var _t [1]Xmpz_srcptr
	Xmpz_set_ui(tls, _r, uint32(bool2int(_k <= _n)))
	if _k > (_n >> 1) {
		_k = func() uint32 {
			if _k <= _n {
				return (_n - _k)
			}
			return 0
		}()
	}
	Xmpz_init(tls, &_t)
	Xmpz_fac_ui(tls, &_t, _k)
_3:
	if _k <= 0 {
		goto _6
	}
	Xmpz_mul_ui(tls, _r, _r, postInc2(&_n, uint32(4294967295)))
	_k -= 1
	goto _3
_6:
	Xmpz_divexact(tls, _r, _r, &_t)
	Xmpz_clear(tls, &_t)
}

func Xmpz_probab_prime_p(tls *crt.TLS, _n *[1]Xmpz_srcptr, _reps int32) (r0 int32) {
	var _is_prime, _j int32
	var _k uint32
	var _nm1, _q, _y [1]Xmpz_srcptr
	if (bool2int((_n[0].X_mp_size) != int32(0)) & int32(*(_n[0].X_mp_d))) == 0 {
		return func() int32 {
			if Xmpz_cmpabs_ui(tls, _n, uint32(2)) == int32(0) {
				return int32(2)
			}
			return int32(0)
		}()
	}

	if Xmpz_cmpabs_ui(tls, _n, uint32(64)) < int32(0) {
		return int32((uint32(3379140316) >> uint(int32((*(_n[0].X_mp_d))>>1))) & uint32(2))
	}
	if Xmpz_gcd_ui(tls, nil, _n, uint32(3234846615)) != uint32(1) {
		return int32(0)
	}
	if Xmpz_cmpabs_ui(tls, _n, uint32(961)) < int32(0) {
		return int32(2)
	}
	Xmpz_init(tls, &_nm1)
	Xmpz_init(tls, &_q)
	Xmpz_init(tls, &_y)
	_nm1[0].X_mp_size = _mpz_abs_sub_ui(tls, &_nm1, _n, uint32(1))
	_k = Xmpz_scan1(tls, &_nm1, 0)
	Xmpz_tdiv_q_2exp(tls, &_q, &_nm1, _k)
	*func() *int32 { _j = int32(0); return &_is_prime }() = int32(1)
_6:
	if (_is_prime & bool2int(_j < _reps)) == 0 {
		goto _9
	}
	Xmpz_set_ui(tls, &_y, ((uint32(_j)*uint32(_j))+uint32(_j))+uint32(41))
	if Xmpz_cmp(tls, &_y, &_nm1) >= int32(0) {
		goto _9
	}
	_is_prime = _gmp_millerrabin(tls, _n, &_nm1, &_y, &_q, _k)
	_j += 1
	goto _6
_9:
	Xmpz_clear(tls, &_nm1)
	Xmpz_clear(tls, &_q)
	Xmpz_clear(tls, &_y)
	return _is_prime
}

func Xmpz_scan1(tls *crt.TLS, _u *[1]Xmpz_srcptr, _starting_bit uint32) (r0 uint32) {
	var _us, _un, _i int32
	var _limb, _ux uint32
	var _up *uint32
	_us = _u[0].X_mp_size
	_un = func() int32 {
		if _us >= int32(0) {
			return _us
		}
		return (-_us)
	}()
	_i = int32(_starting_bit / uint32(32))
	if _i >= _un {
		return func() uint32 {
			if _us >= int32(0) {
				return uint32(4294967295)
			}
			return _starting_bit
		}()
	}
	_up = _u[0].X_mp_d
	_ux = 0
	_limb = *elem0(_up, uintptr(_i))
	if _starting_bit == 0 {
		goto _5
	}
	if _us < int32(0) {
		_ux = uint32(Xmpn_zero_p(tls, _up, _i))
		_limb = (^_limb) + _ux
		_ux = -uint32(bool2int(_limb >= _ux))
	}
	_limb &= uint32(4294967295) << uint(int32(_starting_bit%uint32(32)))
_5:
	return _mpn_common_scan(tls, _limb, _i, _up, _un, _ux)
}

// C comment
//  /* Primality testing */
func _gmp_millerrabin(tls *crt.TLS, _n *[1]Xmpz_srcptr, _nm1 *[1]Xmpz_srcptr, _y *[1]Xmpz_srcptr, _q *[1]Xmpz_srcptr, _k uint32) (r0 int32) {
	Xmpz_powm(tls, _y, _y, _q, _n)
	if (Xmpz_cmp_ui(tls, _y, uint32(1)) == int32(0)) || (Xmpz_cmp(tls, _y, _nm1) == int32(0)) {
		return int32(1)
	}
_1:
	if preInc2(&_k, uint32(4294967295)) <= 0 {
		goto _3
	}
	Xmpz_powm_ui(tls, _y, _y, uint32(2), _n)
	if Xmpz_cmp(tls, _y, _nm1) == int32(0) {
		return int32(1)
	}
	if Xmpz_cmp_ui(tls, _y, uint32(1)) <= int32(0) {
		return int32(0)
	}
	goto _1
_3:
	return int32(0)
}

func Xmpz_clrbit(tls *crt.TLS, _d *[1]Xmpz_srcptr, _bit_index uint32) {
	if Xmpz_tstbit(tls, _d, _bit_index) == 0 {
		goto _0
	}
	if (_d[0].X_mp_size) >= int32(0) {
		_mpz_abs_sub_bit(tls, _d, _bit_index)
		goto _2
	}
	_mpz_abs_add_bit(tls, _d, _bit_index)
_2:
_0:
}

func Xmpz_combit(tls *crt.TLS, _d *[1]Xmpz_srcptr, _bit_index uint32) {
	if (Xmpz_tstbit(tls, _d, _bit_index) ^ bool2int((_d[0].X_mp_size) < int32(0))) != 0 {
		_mpz_abs_sub_bit(tls, _d, _bit_index)
		goto _1
	}
	_mpz_abs_add_bit(tls, _d, _bit_index)
_1:
}

func Xmpz_com(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr) {
	Xmpz_neg(tls, _r, _u)
	Xmpz_sub_ui(tls, _r, _r, uint32(1))
}

func Xmpz_and(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v *[1]Xmpz_srcptr) {
	var _un, _vn, _rn, _i, _3___mp_size_t_swap__tmp int32
	var _ux, _vx, _rx, _uc, _vc, _rc, _ul, _vl, _rl uint32
	var _up, _vp, _rp *uint32
	var _2___mpz_srcptr_swap__tmp *Xmpz_srcptr
	_un = func() int32 {
		if (_u[0].X_mp_size) >= int32(0) {
			return (_u[0].X_mp_size)
		}
		return (-(_u[0].X_mp_size))
	}()
	_vn = func() int32 {
		if (_v[0].X_mp_size) >= int32(0) {
			return (_v[0].X_mp_size)
		}
		return (-(_v[0].X_mp_size))
	}()
	if _un >= _vn {
		goto _4
	}
	_2___mpz_srcptr_swap__tmp = &_u[0]
	_u = _v
	_v = (*[1]Xmpz_srcptr)(unsafe.Pointer(_2___mpz_srcptr_swap__tmp))
	_3___mp_size_t_swap__tmp = _un
	_un = _vn
	_vn = _3___mp_size_t_swap__tmp
_4:
	if _vn == int32(0) {
		_r[0].X_mp_size = int32(0)
		return
	}
	_uc = uint32(bool2int((_u[0].X_mp_size) < int32(0)))
	_vc = uint32(bool2int((_v[0].X_mp_size) < int32(0)))
	_rc = _uc & _vc
	_ux = -_uc
	_vx = -_vc
	_rx = -_rc
	_rn = func() int32 {
		if _vx != 0 {
			return _un
		}
		return _vn
	}()
	_rp = func() *uint32 {
		if (_rn + int32(_rc)) > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _rn+int32(_rc))
		}
		return (_r[0].X_mp_d)
	}()
	_up = _u[0].X_mp_d
	_vp = _v[0].X_mp_d
	_i = int32(0)
_12:
	_ul = ((*elem0(_up, uintptr(_i))) ^ _ux) + _uc
	_uc = uint32(bool2int(_ul < _uc))
	_vl = ((*elem0(_vp, uintptr(_i))) ^ _vx) + _vc
	_vc = uint32(bool2int(_vl < _vc))
	_rl = ((_ul & _vl) ^ _rx) + _rc
	_rc = uint32(bool2int(_rl < _rc))
	*elem0(_rp, uintptr(_i)) = _rl
	if preInc1(&_i, 1) < _vn {
		goto _12
	}

_13:
	if _i >= _rn {
		goto _16
	}
	_ul = ((*elem0(_up, uintptr(_i))) ^ _ux) + _uc
	_uc = uint32(bool2int(_ul < _uc))
	_rl = ((_ul & _vx) ^ _rx) + _rc
	_rc = uint32(bool2int(_rl < _rc))
	*elem0(_rp, uintptr(_i)) = _rl
	_i += 1
	goto _13
_16:
	if _rc != 0 {
		*elem0(_rp, uintptr(postInc1(&_rn, 1))) = _rc
		goto _18
	}
	_rn = _mpn_normalized_size(tls, _rp, _rn)
_18:
	_r[0].X_mp_size = func() int32 {
		if _rx != 0 {
			return (-_rn)
		}
		return _rn
	}()
}

func Xmpz_ior(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v *[1]Xmpz_srcptr) {
	var _un, _vn, _rn, _i, _3___mp_size_t_swap__tmp int32
	var _ux, _vx, _rx, _uc, _vc, _rc, _ul, _vl, _rl uint32
	var _up, _vp, _rp *uint32
	var _2___mpz_srcptr_swap__tmp *Xmpz_srcptr
	_un = func() int32 {
		if (_u[0].X_mp_size) >= int32(0) {
			return (_u[0].X_mp_size)
		}
		return (-(_u[0].X_mp_size))
	}()
	_vn = func() int32 {
		if (_v[0].X_mp_size) >= int32(0) {
			return (_v[0].X_mp_size)
		}
		return (-(_v[0].X_mp_size))
	}()
	if _un >= _vn {
		goto _4
	}
	_2___mpz_srcptr_swap__tmp = &_u[0]
	_u = _v
	_v = (*[1]Xmpz_srcptr)(unsafe.Pointer(_2___mpz_srcptr_swap__tmp))
	_3___mp_size_t_swap__tmp = _un
	_un = _vn
	_vn = _3___mp_size_t_swap__tmp
_4:
	if _vn == int32(0) {
		Xmpz_set(tls, _r, _u)
		return
	}
	_uc = uint32(bool2int((_u[0].X_mp_size) < int32(0)))
	_vc = uint32(bool2int((_v[0].X_mp_size) < int32(0)))
	_rc = _uc | _vc
	_ux = -_uc
	_vx = -_vc
	_rx = -_rc
	_rn = func() int32 {
		if _vx != 0 {
			return _vn
		}
		return _un
	}()
	_rp = func() *uint32 {
		if (_rn + int32(_rc)) > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _rn+int32(_rc))
		}
		return (_r[0].X_mp_d)
	}()
	_up = _u[0].X_mp_d
	_vp = _v[0].X_mp_d
	_i = int32(0)
_12:
	_ul = ((*elem0(_up, uintptr(_i))) ^ _ux) + _uc
	_uc = uint32(bool2int(_ul < _uc))
	_vl = ((*elem0(_vp, uintptr(_i))) ^ _vx) + _vc
	_vc = uint32(bool2int(_vl < _vc))
	_rl = ((_ul | _vl) ^ _rx) + _rc
	_rc = uint32(bool2int(_rl < _rc))
	*elem0(_rp, uintptr(_i)) = _rl
	if preInc1(&_i, 1) < _vn {
		goto _12
	}

_13:
	if _i >= _rn {
		goto _16
	}
	_ul = ((*elem0(_up, uintptr(_i))) ^ _ux) + _uc
	_uc = uint32(bool2int(_ul < _uc))
	_rl = ((_ul | _vx) ^ _rx) + _rc
	_rc = uint32(bool2int(_rl < _rc))
	*elem0(_rp, uintptr(_i)) = _rl
	_i += 1
	goto _13
_16:
	if _rc != 0 {
		*elem0(_rp, uintptr(postInc1(&_rn, 1))) = _rc
		goto _18
	}
	_rn = _mpn_normalized_size(tls, _rp, _rn)
_18:
	_r[0].X_mp_size = func() int32 {
		if _rx != 0 {
			return (-_rn)
		}
		return _rn
	}()
}

func Xmpz_xor(tls *crt.TLS, _r *[1]Xmpz_srcptr, _u *[1]Xmpz_srcptr, _v *[1]Xmpz_srcptr) {
	var _un, _vn, _i, _3___mp_size_t_swap__tmp int32
	var _ux, _vx, _rx, _uc, _vc, _rc, _ul, _vl, _rl uint32
	var _up, _vp, _rp *uint32
	var _2___mpz_srcptr_swap__tmp *Xmpz_srcptr
	_un = func() int32 {
		if (_u[0].X_mp_size) >= int32(0) {
			return (_u[0].X_mp_size)
		}
		return (-(_u[0].X_mp_size))
	}()
	_vn = func() int32 {
		if (_v[0].X_mp_size) >= int32(0) {
			return (_v[0].X_mp_size)
		}
		return (-(_v[0].X_mp_size))
	}()
	if _un >= _vn {
		goto _4
	}
	_2___mpz_srcptr_swap__tmp = &_u[0]
	_u = _v
	_v = (*[1]Xmpz_srcptr)(unsafe.Pointer(_2___mpz_srcptr_swap__tmp))
	_3___mp_size_t_swap__tmp = _un
	_un = _vn
	_vn = _3___mp_size_t_swap__tmp
_4:
	if _vn == int32(0) {
		Xmpz_set(tls, _r, _u)
		return
	}
	_uc = uint32(bool2int((_u[0].X_mp_size) < int32(0)))
	_vc = uint32(bool2int((_v[0].X_mp_size) < int32(0)))
	_rc = _uc ^ _vc
	_ux = -_uc
	_vx = -_vc
	_rx = -_rc
	_rp = func() *uint32 {
		if (_un + int32(_rc)) > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _un+int32(_rc))
		}
		return (_r[0].X_mp_d)
	}()
	_up = _u[0].X_mp_d
	_vp = _v[0].X_mp_d
	_i = int32(0)
_10:
	_ul = ((*elem0(_up, uintptr(_i))) ^ _ux) + _uc
	_uc = uint32(bool2int(_ul < _uc))
	_vl = ((*elem0(_vp, uintptr(_i))) ^ _vx) + _vc
	_vc = uint32(bool2int(_vl < _vc))
	_rl = ((_ul ^ _vl) ^ _rx) + _rc
	_rc = uint32(bool2int(_rl < _rc))
	*elem0(_rp, uintptr(_i)) = _rl
	if preInc1(&_i, 1) < _vn {
		goto _10
	}

_11:
	if _i >= _un {
		goto _14
	}
	_ul = ((*elem0(_up, uintptr(_i))) ^ _ux) + _uc
	_uc = uint32(bool2int(_ul < _uc))
	_rl = (_ul ^ _ux) + _rc
	_rc = uint32(bool2int(_rl < _rc))
	*elem0(_rp, uintptr(_i)) = _rl
	_i += 1
	goto _11
_14:
	if _rc != 0 {
		*elem0(_rp, uintptr(postInc1(&_un, 1))) = _rc
		goto _16
	}
	_un = _mpn_normalized_size(tls, _rp, _un)
_16:
	_r[0].X_mp_size = func() int32 {
		if _rx != 0 {
			return (-_un)
		}
		return _un
	}()
}

func Xmpz_popcount(tls *crt.TLS, _u *[1]Xmpz_srcptr) (r0 uint32) {
	var _un int32
	_un = _u[0].X_mp_size
	if _un < int32(0) {
		return uint32(4294967295)
	}
	return Xmpn_popcount(tls, _u[0].X_mp_d, _un)
}

func Xmpz_hamdist(tls *crt.TLS, _u *[1]Xmpz_srcptr, _v *[1]Xmpz_srcptr) (r0 uint32) {
	var _un, _vn, _i, _4___mp_size_t_swap__tmp int32
	var _uc, _vc, _ul, _vl, _comp, _c uint32
	var _up, _vp, _3___mp_srcptr_swap__tmp *uint32
	_un = _u[0].X_mp_size
	_vn = _v[0].X_mp_size
	if (_un ^ _vn) < int32(0) {
		return uint32(4294967295)
	}
	_comp = -store2(&_uc, store2(&_vc, uint32(bool2int(_un < int32(0)))))
	if _uc != 0 {
		_un = -_un
		_vn = -_vn
	}
	_up = _u[0].X_mp_d
	_vp = _v[0].X_mp_d
	if _un >= _vn {
		goto _2
	}
	_3___mp_srcptr_swap__tmp = _up
	_up = _vp
	_vp = _3___mp_srcptr_swap__tmp
	_4___mp_size_t_swap__tmp = _un
	_un = _vn
	_vn = _4___mp_size_t_swap__tmp
_2:
	*func() *uint32 { _i = int32(0); return &_c }() = 0
_6:
	if _i >= _vn {
		goto _9
	}
	_ul = ((*elem0(_up, uintptr(_i))) ^ _comp) + _uc
	_uc = uint32(bool2int(_ul < _uc))
	_vl = ((*elem0(_vp, uintptr(_i))) ^ _comp) + _vc
	_vc = uint32(bool2int(_vl < _vc))
	_c += _gmp_popcount_limb(tls, _ul^_vl)
	_i += 1
	goto _6
_9:

_10:
	if _i >= _un {
		goto _13
	}
	_ul = ((*elem0(_up, uintptr(_i))) ^ _comp) + _uc
	_uc = uint32(bool2int(_ul < _uc))
	_c += _gmp_popcount_limb(tls, _ul^_comp)
	_i += 1
	goto _10
_13:
	return _c
}

func Xmpz_scan0(tls *crt.TLS, _u *[1]Xmpz_srcptr, _starting_bit uint32) (r0 uint32) {
	var _us, _un, _i int32
	var _limb, _ux uint32
	var _up *uint32
	_us = _u[0].X_mp_size
	_ux = -uint32(bool2int(_us >= int32(0)))
	_un = func() int32 {
		if _us >= int32(0) {
			return _us
		}
		return (-_us)
	}()
	_i = int32(_starting_bit / uint32(32))
	if _i >= _un {
		return func() uint32 {
			if _ux != 0 {
				return _starting_bit
			}
			return uint32(4294967295)
		}()
	}
	_up = _u[0].X_mp_d
	_limb = (*elem0(_up, uintptr(_i))) ^ _ux
	if _ux == 0 {
		_limb -= uint32(Xmpn_zero_p(tls, _up, _i))
	}
	_limb &= uint32(4294967295) << uint(int32(_starting_bit%uint32(32)))
	return _mpn_common_scan(tls, _limb, _i, _up, _un, _ux)
}

func Xmpz_fits_slong_p(tls *crt.TLS, _u *[1]Xmpz_srcptr) (r0 int32) {
	var _us int32
	_us = _u[0].X_mp_size
	if _us == int32(1) {
		return bool2int((*(_u[0].X_mp_d)) < uint32(2147483648))
	}
	if _us == int32(-1) {
		return bool2int((*(_u[0].X_mp_d)) <= uint32(2147483648))
	}
	return bool2int(_us == int32(0))
}

func Xmpz_fits_ulong_p(tls *crt.TLS, _u *[1]Xmpz_srcptr) (r0 int32) {
	var _us int32
	_us = _u[0].X_mp_size
	return bool2int(_us == bool2int(_us > int32(0)))
}

func Xmpz_get_si(tls *crt.TLS, _u *[1]Xmpz_srcptr) (r0 int32) {
	if (_u[0].X_mp_size) < int32(0) {
		return int32(-1) - int32(((*(_u[0].X_mp_d))-uint32(1))&uint32(2147483647))
	}
	return int32(Xmpz_get_ui(tls, _u) & uint32(2147483647))
}

func Xmpz_get_d(tls *crt.TLS, _u *[1]Xmpz_srcptr) (r0 float64) {
	var _un int32
	var _x, _B float64
	_B = 4.294967296e+09
	_un = func() int32 {
		if (_u[0].X_mp_size) >= int32(0) {
			return (_u[0].X_mp_size)
		}
		return (-(_u[0].X_mp_size))
	}()
	if _un == int32(0) {
		return float64(0)
	}
	_x = float64(*elem0(_u[0].X_mp_d, uintptr(preInc1(&_un, -1))))
_3:
	if _un > int32(0) {
		_x = (_B * _x) + float64(*elem0(_u[0].X_mp_d, uintptr(preInc1(&_un, -1))))
		goto _3
	}
	if (_u[0].X_mp_size) < int32(0) {
		_x = -_x
	}
	return _x
}

func Xmpz_size(tls *crt.TLS, _u *[1]Xmpz_srcptr) (r0 uint32) {
	return uint32(func() int32 {
		if (_u[0].X_mp_size) >= int32(0) {
			return (_u[0].X_mp_size)
		}
		return (-(_u[0].X_mp_size))
	}())
}

func Xmpz_getlimbn(tls *crt.TLS, _u *[1]Xmpz_srcptr, _n int32) (r0 uint32) {
	if (_n >= int32(0)) && (_n < func() int32 {
		if (_u[0].X_mp_size) >= int32(0) {
			return (_u[0].X_mp_size)
		}
		return (-(_u[0].X_mp_size))
	}()) {
		return *elem0(_u[0].X_mp_d, uintptr(_n))
	}
	return 0
}

func Xmpz_realloc2(tls *crt.TLS, _x *[1]Xmpz_srcptr, _n uint32) {
	_mpz_realloc(tls, _x, int32(uint32(1)+((_n-uint32(bool2int(_n != 0)))/uint32(32))))
}

func Xmpz_limbs_read(tls *crt.TLS, _x *Xmpz_srcptr) (r0 *uint32) {
	return _x.X_mp_d
}

func Xmpz_limbs_modify(tls *crt.TLS, _x *[1]Xmpz_srcptr, _n int32) (r0 *uint32) {
	return func() *uint32 {
		if _n > (_x[0].X_mp_alloc) {
			return _mpz_realloc(tls, _x, _n)
		}
		return (_x[0].X_mp_d)
	}()
}

func Xmpz_limbs_write(tls *crt.TLS, _x *[1]Xmpz_srcptr, _n int32) (r0 *uint32) {
	return Xmpz_limbs_modify(tls, _x, _n)
}

// C comment
//  /* Conversions and comparison to double. */
func Xmpz_set_d(tls *crt.TLS, _r *[1]Xmpz_srcptr, _x float64) {
	var _sign, _rn, _i int32
	var _f uint32
	var _B, _Bi float64
	var _rp *uint32
	if (_x != _x) || (_x == (_x * 0.5)) {
		_r[0].X_mp_size = int32(0)
		return
	}
	_sign = bool2int(_x < float64(0))
	if _sign != 0 {
		_x = -_x
	}
	if _x < float64(1) {
		_r[0].X_mp_size = int32(0)
		return
	}
	_B = 4.294967296e+09
	_Bi = float64(1) / _B
	_rn = int32(1)
_4:
	if _x < _B {
		goto _7
	}
	_x *= _Bi
	_rn += 1
	goto _4
_7:
	_rp = func() *uint32 {
		if _rn > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _rn)
		}
		return (_r[0].X_mp_d)
	}()
	_f = uint32(_x)
	_x -= float64(_f)

	_i = _rn - int32(1)
	*elem0(_rp, uintptr(_i)) = _f
_10:
	if preInc1(&_i, -1) >= int32(0) {
		_x = _B * _x
		_f = uint32(_x)
		_x -= float64(_f)

		*elem0(_rp, uintptr(_i)) = _f
		goto _10
	}
	_r[0].X_mp_size = func() int32 {
		if _sign != 0 {
			return (-_rn)
		}
		return _rn
	}()
}

func Xmpz_init_set_si(tls *crt.TLS, _r *[1]Xmpz_srcptr, _x int32) {
	Xmpz_init(tls, _r)
	Xmpz_set_si(tls, _r, _x)
}

func Xmpz_init_set_d(tls *crt.TLS, _r *[1]Xmpz_srcptr, _x float64) {
	Xmpz_init(tls, _r)
	Xmpz_set_d(tls, _r, _x)
}

func Xmpz_get_str(tls *crt.TLS, _sp *int8, _base int32, _u *[1]Xmpz_srcptr) (r0 *int8) {
	var _un int32
	var _bits, _i, _sn uint32
	var _digits *int8
	var _4_tp *uint32
	var _4_info Tmpn_base_info
	if _base >= int32(0) {
		_digits = str(274)
		goto _1
	}
	_base = -_base
	_digits = str(311)
_1:
	if _base <= int32(1) {
		_base = int32(10)
	}
	if _base > int32(36) {
		return nil
	}
	_sn = uint32(1) + Xmpz_sizeinbase(tls, _u, _base)
	if _sp == nil {
		_sp = (*int8)(_gmp_allocate_func(tls, uint32(1)+_sn))
	}
	_un = func() int32 {
		if (_u[0].X_mp_size) >= int32(0) {
			return (_u[0].X_mp_size)
		}
		return (-(_u[0].X_mp_size))
	}()
	if _un == int32(0) {
		*_sp = int8(48)
		*elem4(_sp, uintptr(1)) = 0
		return _sp
	}
	_i = 0
	if (_u[0].X_mp_size) < int32(0) {
		*elem4(_sp, uintptr(postInc2(&_i, uint32(1)))) = int8(45)
	}
	_bits = _mpn_base_power_of_two_p(tls, uint32(_base))
	if _bits != 0 {
		_sn = _i + _mpn_get_str_bits(tls, elem3((*uint8)(unsafe.Pointer(_sp)), uintptr(_i)), _bits, _u[0].X_mp_d, _un)
		goto _10
	}
	_mpn_get_base_info(tls, &_4_info, uint32(_base))
	_4_tp = _gmp_xalloc_limbs(tls, _un)
	Xmpn_copyi(tls, _4_tp, _u[0].X_mp_d, _un)
	_sn = _i + _mpn_get_str_other(tls, elem3((*uint8)(unsafe.Pointer(_sp)), uintptr(_i)), _base, &_4_info, _4_tp, _un)
	_gmp_free_func(tls, unsafe.Pointer(_4_tp), 0)
_10:
	if _i >= _sn {
		goto _14
	}
	*elem4(_sp, uintptr(_i)) = *elem4(_digits, uintptr(uint8(*elem4(_sp, uintptr(_i)))))
	_i += 1
	goto _10
_14:
	*elem4(_sp, uintptr(_sn)) = 0
	return _sp
}

func Xmpz_set_str(tls *crt.TLS, _r *[1]Xmpz_srcptr, _sp *int8, _base int32) (r0 int32) {
	var _rn, _alloc, _sign int32
	var _bits, _dn, _6_digit uint32
	var _dp *uint8
	var _rp *uint32
	var _10_info Tmpn_base_info

_0:
	if (int32(*elem5(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*_sp))))) & int32(8192)) != 0 {
		*(*uintptr)(unsafe.Pointer(&_sp)) += uintptr(1)
		goto _0
	}
	_sign = bool2int(int32(*_sp) == int32(45))
	*(*uintptr)(unsafe.Pointer(&_sp)) += uintptr(_sign)
	if _base != int32(0) {
		goto _2
	}
	if int32(*_sp) != int32(48) {
		goto _3
	}
	if (int32(*elem4(_sp, uintptr(1))) == int32(120)) || (int32(*elem4(_sp, uintptr(1))) == int32(88)) {
		_base = int32(16)
		*(*uintptr)(unsafe.Pointer(&_sp)) += uintptr(int32(2))
		goto _9
	}
	if (int32(*elem4(_sp, uintptr(1))) == int32(98)) || (int32(*elem4(_sp, uintptr(1))) == int32(66)) {
		_base = int32(2)
		*(*uintptr)(unsafe.Pointer(&_sp)) += uintptr(int32(2))
		goto _9
	}
	_base = int32(8)
_9:
	goto _10
_3:
	_base = int32(10)
_10:
_2:
	if (*_sp) == 0 {
		_r[0].X_mp_size = int32(0)
		return int32(-1)
	}
	_dp = (*uint8)(_gmp_allocate_func(tls, crt.Xstrlen(tls, _sp)))
	_dn = 0
_12:
	if (*_sp) == 0 {
		goto _15
	}
	if (int32(*elem5(*crt.X__ctype_b_loc(tls), uintptr(int32(uint8(*_sp))))) & int32(8192)) != 0 {
		goto _13
	}
	if (int32(*_sp) >= int32(48)) && (int32(*_sp) <= int32(57)) {
		_6_digit = uint32(int32(*_sp) - int32(48))
		goto _26
	}
	if (int32(*_sp) >= int32(97)) && (int32(*_sp) <= int32(122)) {
		_6_digit = uint32((int32(*_sp) - int32(97)) + int32(10))
		goto _26
	}
	if (int32(*_sp) >= int32(65)) && (int32(*_sp) <= int32(90)) {
		_6_digit = uint32((int32(*_sp) - int32(65)) + int32(10))
		goto _26
	}
	_6_digit = uint32(_base)
_26:
	if _6_digit >= uint32(_base) {
		_gmp_free_func(tls, unsafe.Pointer(_dp), 0)
		_r[0].X_mp_size = int32(0)
		return int32(-1)
	}
	*elem3(_dp, uintptr(postInc2(&_dn, uint32(1)))) = uint8(_6_digit)
_13:
	*(*uintptr)(unsafe.Pointer(&_sp)) += uintptr(1)
	goto _12
_15:
	if _dn == 0 {
		_gmp_free_func(tls, unsafe.Pointer(_dp), 0)
		_r[0].X_mp_size = int32(0)
		return int32(-1)
	}
	_bits = _mpn_base_power_of_two_p(tls, uint32(_base))
	if _bits > 0 {
		_alloc = int32((((_dn * _bits) + uint32(32)) - uint32(1)) / uint32(32))
		_rp = func() *uint32 {
			if _alloc > (_r[0].X_mp_alloc) {
				return _mpz_realloc(tls, _r, _alloc)
			}
			return (_r[0].X_mp_d)
		}()
		_rn = _mpn_set_str_bits(tls, _rp, _dp, _dn, _bits)
		goto _32
	}
	_mpn_get_base_info(tls, &_10_info, uint32(_base))
	_alloc = int32(((_dn + _10_info.Xexp) - uint32(1)) / _10_info.Xexp)
	_rp = func() *uint32 {
		if _alloc > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _alloc)
		}
		return (_r[0].X_mp_d)
	}()
	_rn = _mpn_set_str_other(tls, _rp, _dp, _dn, uint32(_base), &_10_info)

	_rn -= bool2int((*elem0(_rp, uintptr(_rn-int32(1)))) == 0)
_32:

	_gmp_free_func(tls, unsafe.Pointer(_dp), 0)
	_r[0].X_mp_size = func() int32 {
		if _sign != 0 {
			return (-_rn)
		}
		return _rn
	}()
	return int32(0)
}

func Xmpz_init_set_str(tls *crt.TLS, _r *[1]Xmpz_srcptr, _sp *int8, _base int32) (r0 int32) {
	Xmpz_init(tls, _r)
	return Xmpz_set_str(tls, _r, _sp, _base)
}

func Xmpz_out_str(tls *crt.TLS, _stream *crt.XFILE, _base int32, _x *[1]Xmpz_srcptr) (r0 uint32) {
	var _len uint32
	var _str *int8
	_str = Xmpz_get_str(tls, nil, _base, _x)
	_len = crt.Xstrlen(tls, _str)
	_len = crt.Xfwrite(tls, unsafe.Pointer(_str), uint32(1), _len, _stream)
	_gmp_free_func(tls, unsafe.Pointer(_str), 0)
	return _len
}

// C comment
//  /* Import and export. Does not support nails. */
func Xmpz_import(tls *crt.TLS, _r *[1]Xmpz_srcptr, _count uint32, _order int32, _size uint32, _endian int32, _nails uint32, _src unsafe.Pointer) {
	var _word_step, _rn, _i int32
	var _limb, _bytes, _2_j uint32
	var _p *uint8
	var _rp *uint32
	if _nails != 0 {
		_gmp_die(tls, str(348))
	}

	if _endian == int32(0) {
		_endian = _gmp_detect_endian(tls)
	}
	_p = (*uint8)(_src)
	_word_step = int32(func() uint32 {
		if _order != _endian {
			return (uint32(2) * _size)
		}
		return 0
	}())
	if _order == int32(1) {
		*(*uintptr)(unsafe.Pointer(&_p)) += uintptr(_size * (_count - uint32(1)))
		_word_step = -_word_step
	}
	if _endian == int32(1) {
		*(*uintptr)(unsafe.Pointer(&_p)) += uintptr(_size - uint32(1))
	}
	_rn = int32((((_size * _count) + uint32(4)) - uint32(1)) / uint32(4))
	_rp = func() *uint32 {
		if _rn > (_r[0].X_mp_alloc) {
			return _mpz_realloc(tls, _r, _rn)
		}
		return (_r[0].X_mp_d)
	}()
	*func() *int32 { *func() *uint32 { _limb = 0; return &_bytes }() = 0; return &_i }() = int32(0)
_8:
	if _count <= 0 {
		goto _11
	}
	_2_j = 0
_12:
	if _2_j >= _size {
		goto _15
	}
	_limb |= uint32(*_p) << uint(int32(postInc2(&_bytes, uint32(1))*uint32(8)))
	if _bytes == uint32(4) {
		*elem0(_rp, uintptr(postInc1(&_i, 1))) = _limb
		_bytes = 0
		_limb = 0
	}
	*(*uintptr)(unsafe.Pointer(func() **uint8 { _2_j += 1; return &_p }())) -= uintptr(_endian)
	goto _12
_15:
	*(*uintptr)(unsafe.Pointer(func() **uint8 { _count -= 1; return &_p }())) += uintptr(_word_step)
	goto _8
_11:

	if _limb != 0 {
		*elem0(_rp, uintptr(postInc1(&_i, 1))) = _limb
		goto _18
	}
	_i = _mpn_normalized_size(tls, _rp, _i)
_18:
	_r[0].X_mp_size = _i
}

func _gmp_detect_endian(tls *crt.TLS) (r0 int32) {
	var _p *uint8
	_p = (*uint8)(unsafe.Pointer(&_gmp_detect_endianØ00iØ001))
	return int32(1) - int32(*_p)
}

var _gmp_detect_endianØ00iØ001 int32

func init() {
	_gmp_detect_endianØ00iØ001 = int32(2)
}

func Xmpz_export(tls *crt.TLS, _r unsafe.Pointer, _countp *uint32, _order int32, _size uint32, _endian int32, _nails uint32, _u *[1]Xmpz_srcptr) (r0 unsafe.Pointer) {
	var _un, _1_word_step, _1_i int32
	var _count, _1_k, _1_limb, _1_bytes, _4_j uint32
	var _1_p *uint8
	if _nails != 0 {
		_gmp_die(tls, str(348))
	}

	_un = _u[0].X_mp_size
	_count = 0
	if _un == int32(0) {
		goto _1
	}
	_un = func() int32 {
		if _un >= int32(0) {
			return _un
		}
		return (-_un)
	}()
	_1_limb = *elem0(_u[0].X_mp_d, uintptr(_un-int32(1)))

	_1_k = 0
_4:
	_1_k += 1
	_1_limb >>= 8
	if _1_limb != 0 {
		goto _4
	}
	_count = (((_1_k + (uint32(_un-int32(1)) * uint32(4))) + _size) - uint32(1)) / _size
	if _r == nil {
		_r = _gmp_allocate_func(tls, _count*_size)
	}
	if _endian == int32(0) {
		_endian = _gmp_detect_endian(tls)
	}
	_1_p = (*uint8)(_r)
	_1_word_step = int32(func() uint32 {
		if _order != _endian {
			return (uint32(2) * _size)
		}
		return 0
	}())
	if _order == int32(1) {
		*(*uintptr)(unsafe.Pointer(&_1_p)) += uintptr(_size * (_count - uint32(1)))
		_1_word_step = -_1_word_step
	}
	if _endian == int32(1) {
		*(*uintptr)(unsafe.Pointer(&_1_p)) += uintptr(_size - uint32(1))
	}
	*func() *uint32 { *func() *int32 { _1_bytes = 0; return &_1_i }() = int32(0); return &_1_k }() = 0
_11:
	if _1_k >= _count {
		goto _14
	}
	_4_j = 0
_15:
	if _4_j >= _size {
		goto _18
	}
	if _1_bytes != 0 {
		goto _19
	}
	if _1_i < _un {
		_1_limb = *elem0(_u[0].X_mp_d, uintptr(postInc1(&_1_i, 1)))
	}
	_1_bytes = uint32(4)
_19:
	*_1_p = uint8(_1_limb)
	_1_limb >>= 8
	_1_bytes -= 1
	*(*uintptr)(unsafe.Pointer(func() **uint8 { _4_j += 1; return &_1_p }())) -= uintptr(_endian)
	goto _15
_18:
	*(*uintptr)(unsafe.Pointer(func() **uint8 { _1_k += 1; return &_1_p }())) += uintptr(_1_word_step)
	goto _11
_14:

_1:
	if _countp != nil {
		*_countp = _count
	}
	return _r
}

func bool2int(b bool) int32 {
	if b {
		return 1
	}
	return 0
}
func bug20530(interface{}) {} //TODO remove when https://github.com/golang/go/issues/20530 is fixed.
func init()                { nzf32 *= -1; nzf64 *= -1 }

var inf = math.Inf(1)
var nzf32 float32 // -0.0
var nzf64 float64 // -0.0
func elem4(a *int8, index uintptr) *int8 {
	return (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + 1*index))
}
func elem5(a *uint16, index uintptr) *uint16 {
	return (*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + 2*index))
}
func elem0(a *uint32, index uintptr) *uint32 {
	return (*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + 4*index))
}
func elem3(a *uint8, index uintptr) *uint8 {
	return (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + 1*index))
}
func postInc0(p **uint32, d int) *uint32 {
	q := (*uintptr)(unsafe.Pointer(p))
	v := *q
	*q += uintptr(d)
	return (*uint32)(unsafe.Pointer(v))
}
func postInc1(p *int32, d int32) int32    { v := *p; *p += d; return v }
func postInc2(p *uint32, d uint32) uint32 { v := *p; *p += d; return v }
func preInc0(p **uint32, d int) *uint32 {
	q := (*uintptr)(unsafe.Pointer(p))
	v := *q + uintptr(d)
	*q = v
	return (*uint32)(unsafe.Pointer(v))
}
func preInc1(p *int32, d int32) int32    { v := *p + d; *p = v; return v }
func preInc2(p *uint32, d uint32) uint32 { v := *p + d; *p = v; return v }
func store2(p *uint32, v uint32) uint32  { *p = v; return v }

type Tgmp_div_inverse struct {
	Xshift uint32
	Xd1    uint32
	Xd0    uint32
	Xdi    uint32
} // t6 struct{shift uint32,d1 uint32,d0 uint32,di uint32}

type Tmpn_base_info struct {
	Xexp uint32
	Xbb  uint32
} // t7 struct{exp uint32,bb uint32}

type Xmpz_srcptr struct {
	X_mp_alloc int32
	X_mp_size  int32
	X_mp_d     *uint32
}                       // t8 struct{_mp_alloc int32,_mp_size int32,_mp_d *uint32}
func str(n int) *int8   { return (*int8)(unsafe.Pointer(&strTab[n])) }
func wstr(n int) *int32 { return (*int32)(unsafe.Pointer(&strTab[n])) }

var strTab = []byte("gmp_default_alloc: Virtual memory exhausted.\x00%s\x0a\x00gmp_default_realloc: Virtual memory exhausted.\x00mpz_rootrem: Negative argument, with even root.\x00mpz_rootrem: Zeroth root.\x00mpz_div_qr: Divide by zero.\x00mpz_powm: Zero modulo.\x00mpz_powm: Negative exponent and non-invertible base.\x000123456789abcdefghijklmnopqrstuvwxyz\x000123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\x00mpz_import: Nails not supported.\x00")
